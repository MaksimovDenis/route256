// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	"context"
	"route256/loms/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// EventRepositoryMock implements mm_orderevent.eventRepository
type EventRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcFetchNextMessages          func(ctx context.Context, limit int32) (ea1 []domain.Event, err error)
	funcFetchNextMessagesOrigin    string
	inspectFuncFetchNextMessages   func(ctx context.Context, limit int32)
	afterFetchNextMessagesCounter  uint64
	beforeFetchNextMessagesCounter uint64
	FetchNextMessagesMock          mEventRepositoryMockFetchNextMessages

	funcMarkAsError          func(ctx context.Context, orderIDs []int64) (err error)
	funcMarkAsErrorOrigin    string
	inspectFuncMarkAsError   func(ctx context.Context, orderIDs []int64)
	afterMarkAsErrorCounter  uint64
	beforeMarkAsErrorCounter uint64
	MarkAsErrorMock          mEventRepositoryMockMarkAsError

	funcMarkAsSent          func(ctx context.Context, ids []int64) (err error)
	funcMarkAsSentOrigin    string
	inspectFuncMarkAsSent   func(ctx context.Context, ids []int64)
	afterMarkAsSentCounter  uint64
	beforeMarkAsSentCounter uint64
	MarkAsSentMock          mEventRepositoryMockMarkAsSent
}

// NewEventRepositoryMock returns a mock for mm_orderevent.eventRepository
func NewEventRepositoryMock(t minimock.Tester) *EventRepositoryMock {
	m := &EventRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.FetchNextMessagesMock = mEventRepositoryMockFetchNextMessages{mock: m}
	m.FetchNextMessagesMock.callArgs = []*EventRepositoryMockFetchNextMessagesParams{}

	m.MarkAsErrorMock = mEventRepositoryMockMarkAsError{mock: m}
	m.MarkAsErrorMock.callArgs = []*EventRepositoryMockMarkAsErrorParams{}

	m.MarkAsSentMock = mEventRepositoryMockMarkAsSent{mock: m}
	m.MarkAsSentMock.callArgs = []*EventRepositoryMockMarkAsSentParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mEventRepositoryMockFetchNextMessages struct {
	optional           bool
	mock               *EventRepositoryMock
	defaultExpectation *EventRepositoryMockFetchNextMessagesExpectation
	expectations       []*EventRepositoryMockFetchNextMessagesExpectation

	callArgs []*EventRepositoryMockFetchNextMessagesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EventRepositoryMockFetchNextMessagesExpectation specifies expectation struct of the eventRepository.FetchNextMessages
type EventRepositoryMockFetchNextMessagesExpectation struct {
	mock               *EventRepositoryMock
	params             *EventRepositoryMockFetchNextMessagesParams
	paramPtrs          *EventRepositoryMockFetchNextMessagesParamPtrs
	expectationOrigins EventRepositoryMockFetchNextMessagesExpectationOrigins
	results            *EventRepositoryMockFetchNextMessagesResults
	returnOrigin       string
	Counter            uint64
}

// EventRepositoryMockFetchNextMessagesParams contains parameters of the eventRepository.FetchNextMessages
type EventRepositoryMockFetchNextMessagesParams struct {
	ctx   context.Context
	limit int32
}

// EventRepositoryMockFetchNextMessagesParamPtrs contains pointers to parameters of the eventRepository.FetchNextMessages
type EventRepositoryMockFetchNextMessagesParamPtrs struct {
	ctx   *context.Context
	limit *int32
}

// EventRepositoryMockFetchNextMessagesResults contains results of the eventRepository.FetchNextMessages
type EventRepositoryMockFetchNextMessagesResults struct {
	ea1 []domain.Event
	err error
}

// EventRepositoryMockFetchNextMessagesOrigins contains origins of expectations of the eventRepository.FetchNextMessages
type EventRepositoryMockFetchNextMessagesExpectationOrigins struct {
	origin      string
	originCtx   string
	originLimit string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFetchNextMessages *mEventRepositoryMockFetchNextMessages) Optional() *mEventRepositoryMockFetchNextMessages {
	mmFetchNextMessages.optional = true
	return mmFetchNextMessages
}

// Expect sets up expected params for eventRepository.FetchNextMessages
func (mmFetchNextMessages *mEventRepositoryMockFetchNextMessages) Expect(ctx context.Context, limit int32) *mEventRepositoryMockFetchNextMessages {
	if mmFetchNextMessages.mock.funcFetchNextMessages != nil {
		mmFetchNextMessages.mock.t.Fatalf("EventRepositoryMock.FetchNextMessages mock is already set by Set")
	}

	if mmFetchNextMessages.defaultExpectation == nil {
		mmFetchNextMessages.defaultExpectation = &EventRepositoryMockFetchNextMessagesExpectation{}
	}

	if mmFetchNextMessages.defaultExpectation.paramPtrs != nil {
		mmFetchNextMessages.mock.t.Fatalf("EventRepositoryMock.FetchNextMessages mock is already set by ExpectParams functions")
	}

	mmFetchNextMessages.defaultExpectation.params = &EventRepositoryMockFetchNextMessagesParams{ctx, limit}
	mmFetchNextMessages.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFetchNextMessages.expectations {
		if minimock.Equal(e.params, mmFetchNextMessages.defaultExpectation.params) {
			mmFetchNextMessages.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFetchNextMessages.defaultExpectation.params)
		}
	}

	return mmFetchNextMessages
}

// ExpectCtxParam1 sets up expected param ctx for eventRepository.FetchNextMessages
func (mmFetchNextMessages *mEventRepositoryMockFetchNextMessages) ExpectCtxParam1(ctx context.Context) *mEventRepositoryMockFetchNextMessages {
	if mmFetchNextMessages.mock.funcFetchNextMessages != nil {
		mmFetchNextMessages.mock.t.Fatalf("EventRepositoryMock.FetchNextMessages mock is already set by Set")
	}

	if mmFetchNextMessages.defaultExpectation == nil {
		mmFetchNextMessages.defaultExpectation = &EventRepositoryMockFetchNextMessagesExpectation{}
	}

	if mmFetchNextMessages.defaultExpectation.params != nil {
		mmFetchNextMessages.mock.t.Fatalf("EventRepositoryMock.FetchNextMessages mock is already set by Expect")
	}

	if mmFetchNextMessages.defaultExpectation.paramPtrs == nil {
		mmFetchNextMessages.defaultExpectation.paramPtrs = &EventRepositoryMockFetchNextMessagesParamPtrs{}
	}
	mmFetchNextMessages.defaultExpectation.paramPtrs.ctx = &ctx
	mmFetchNextMessages.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFetchNextMessages
}

// ExpectLimitParam2 sets up expected param limit for eventRepository.FetchNextMessages
func (mmFetchNextMessages *mEventRepositoryMockFetchNextMessages) ExpectLimitParam2(limit int32) *mEventRepositoryMockFetchNextMessages {
	if mmFetchNextMessages.mock.funcFetchNextMessages != nil {
		mmFetchNextMessages.mock.t.Fatalf("EventRepositoryMock.FetchNextMessages mock is already set by Set")
	}

	if mmFetchNextMessages.defaultExpectation == nil {
		mmFetchNextMessages.defaultExpectation = &EventRepositoryMockFetchNextMessagesExpectation{}
	}

	if mmFetchNextMessages.defaultExpectation.params != nil {
		mmFetchNextMessages.mock.t.Fatalf("EventRepositoryMock.FetchNextMessages mock is already set by Expect")
	}

	if mmFetchNextMessages.defaultExpectation.paramPtrs == nil {
		mmFetchNextMessages.defaultExpectation.paramPtrs = &EventRepositoryMockFetchNextMessagesParamPtrs{}
	}
	mmFetchNextMessages.defaultExpectation.paramPtrs.limit = &limit
	mmFetchNextMessages.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmFetchNextMessages
}

// Inspect accepts an inspector function that has same arguments as the eventRepository.FetchNextMessages
func (mmFetchNextMessages *mEventRepositoryMockFetchNextMessages) Inspect(f func(ctx context.Context, limit int32)) *mEventRepositoryMockFetchNextMessages {
	if mmFetchNextMessages.mock.inspectFuncFetchNextMessages != nil {
		mmFetchNextMessages.mock.t.Fatalf("Inspect function is already set for EventRepositoryMock.FetchNextMessages")
	}

	mmFetchNextMessages.mock.inspectFuncFetchNextMessages = f

	return mmFetchNextMessages
}

// Return sets up results that will be returned by eventRepository.FetchNextMessages
func (mmFetchNextMessages *mEventRepositoryMockFetchNextMessages) Return(ea1 []domain.Event, err error) *EventRepositoryMock {
	if mmFetchNextMessages.mock.funcFetchNextMessages != nil {
		mmFetchNextMessages.mock.t.Fatalf("EventRepositoryMock.FetchNextMessages mock is already set by Set")
	}

	if mmFetchNextMessages.defaultExpectation == nil {
		mmFetchNextMessages.defaultExpectation = &EventRepositoryMockFetchNextMessagesExpectation{mock: mmFetchNextMessages.mock}
	}
	mmFetchNextMessages.defaultExpectation.results = &EventRepositoryMockFetchNextMessagesResults{ea1, err}
	mmFetchNextMessages.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFetchNextMessages.mock
}

// Set uses given function f to mock the eventRepository.FetchNextMessages method
func (mmFetchNextMessages *mEventRepositoryMockFetchNextMessages) Set(f func(ctx context.Context, limit int32) (ea1 []domain.Event, err error)) *EventRepositoryMock {
	if mmFetchNextMessages.defaultExpectation != nil {
		mmFetchNextMessages.mock.t.Fatalf("Default expectation is already set for the eventRepository.FetchNextMessages method")
	}

	if len(mmFetchNextMessages.expectations) > 0 {
		mmFetchNextMessages.mock.t.Fatalf("Some expectations are already set for the eventRepository.FetchNextMessages method")
	}

	mmFetchNextMessages.mock.funcFetchNextMessages = f
	mmFetchNextMessages.mock.funcFetchNextMessagesOrigin = minimock.CallerInfo(1)
	return mmFetchNextMessages.mock
}

// When sets expectation for the eventRepository.FetchNextMessages which will trigger the result defined by the following
// Then helper
func (mmFetchNextMessages *mEventRepositoryMockFetchNextMessages) When(ctx context.Context, limit int32) *EventRepositoryMockFetchNextMessagesExpectation {
	if mmFetchNextMessages.mock.funcFetchNextMessages != nil {
		mmFetchNextMessages.mock.t.Fatalf("EventRepositoryMock.FetchNextMessages mock is already set by Set")
	}

	expectation := &EventRepositoryMockFetchNextMessagesExpectation{
		mock:               mmFetchNextMessages.mock,
		params:             &EventRepositoryMockFetchNextMessagesParams{ctx, limit},
		expectationOrigins: EventRepositoryMockFetchNextMessagesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFetchNextMessages.expectations = append(mmFetchNextMessages.expectations, expectation)
	return expectation
}

// Then sets up eventRepository.FetchNextMessages return parameters for the expectation previously defined by the When method
func (e *EventRepositoryMockFetchNextMessagesExpectation) Then(ea1 []domain.Event, err error) *EventRepositoryMock {
	e.results = &EventRepositoryMockFetchNextMessagesResults{ea1, err}
	return e.mock
}

// Times sets number of times eventRepository.FetchNextMessages should be invoked
func (mmFetchNextMessages *mEventRepositoryMockFetchNextMessages) Times(n uint64) *mEventRepositoryMockFetchNextMessages {
	if n == 0 {
		mmFetchNextMessages.mock.t.Fatalf("Times of EventRepositoryMock.FetchNextMessages mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFetchNextMessages.expectedInvocations, n)
	mmFetchNextMessages.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFetchNextMessages
}

func (mmFetchNextMessages *mEventRepositoryMockFetchNextMessages) invocationsDone() bool {
	if len(mmFetchNextMessages.expectations) == 0 && mmFetchNextMessages.defaultExpectation == nil && mmFetchNextMessages.mock.funcFetchNextMessages == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFetchNextMessages.mock.afterFetchNextMessagesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFetchNextMessages.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FetchNextMessages implements mm_orderevent.eventRepository
func (mmFetchNextMessages *EventRepositoryMock) FetchNextMessages(ctx context.Context, limit int32) (ea1 []domain.Event, err error) {
	mm_atomic.AddUint64(&mmFetchNextMessages.beforeFetchNextMessagesCounter, 1)
	defer mm_atomic.AddUint64(&mmFetchNextMessages.afterFetchNextMessagesCounter, 1)

	mmFetchNextMessages.t.Helper()

	if mmFetchNextMessages.inspectFuncFetchNextMessages != nil {
		mmFetchNextMessages.inspectFuncFetchNextMessages(ctx, limit)
	}

	mm_params := EventRepositoryMockFetchNextMessagesParams{ctx, limit}

	// Record call args
	mmFetchNextMessages.FetchNextMessagesMock.mutex.Lock()
	mmFetchNextMessages.FetchNextMessagesMock.callArgs = append(mmFetchNextMessages.FetchNextMessagesMock.callArgs, &mm_params)
	mmFetchNextMessages.FetchNextMessagesMock.mutex.Unlock()

	for _, e := range mmFetchNextMessages.FetchNextMessagesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmFetchNextMessages.FetchNextMessagesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFetchNextMessages.FetchNextMessagesMock.defaultExpectation.Counter, 1)
		mm_want := mmFetchNextMessages.FetchNextMessagesMock.defaultExpectation.params
		mm_want_ptrs := mmFetchNextMessages.FetchNextMessagesMock.defaultExpectation.paramPtrs

		mm_got := EventRepositoryMockFetchNextMessagesParams{ctx, limit}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFetchNextMessages.t.Errorf("EventRepositoryMock.FetchNextMessages got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFetchNextMessages.FetchNextMessagesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmFetchNextMessages.t.Errorf("EventRepositoryMock.FetchNextMessages got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFetchNextMessages.FetchNextMessagesMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFetchNextMessages.t.Errorf("EventRepositoryMock.FetchNextMessages got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFetchNextMessages.FetchNextMessagesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFetchNextMessages.FetchNextMessagesMock.defaultExpectation.results
		if mm_results == nil {
			mmFetchNextMessages.t.Fatal("No results are set for the EventRepositoryMock.FetchNextMessages")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmFetchNextMessages.funcFetchNextMessages != nil {
		return mmFetchNextMessages.funcFetchNextMessages(ctx, limit)
	}
	mmFetchNextMessages.t.Fatalf("Unexpected call to EventRepositoryMock.FetchNextMessages. %v %v", ctx, limit)
	return
}

// FetchNextMessagesAfterCounter returns a count of finished EventRepositoryMock.FetchNextMessages invocations
func (mmFetchNextMessages *EventRepositoryMock) FetchNextMessagesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchNextMessages.afterFetchNextMessagesCounter)
}

// FetchNextMessagesBeforeCounter returns a count of EventRepositoryMock.FetchNextMessages invocations
func (mmFetchNextMessages *EventRepositoryMock) FetchNextMessagesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchNextMessages.beforeFetchNextMessagesCounter)
}

// Calls returns a list of arguments used in each call to EventRepositoryMock.FetchNextMessages.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFetchNextMessages *mEventRepositoryMockFetchNextMessages) Calls() []*EventRepositoryMockFetchNextMessagesParams {
	mmFetchNextMessages.mutex.RLock()

	argCopy := make([]*EventRepositoryMockFetchNextMessagesParams, len(mmFetchNextMessages.callArgs))
	copy(argCopy, mmFetchNextMessages.callArgs)

	mmFetchNextMessages.mutex.RUnlock()

	return argCopy
}

// MinimockFetchNextMessagesDone returns true if the count of the FetchNextMessages invocations corresponds
// the number of defined expectations
func (m *EventRepositoryMock) MinimockFetchNextMessagesDone() bool {
	if m.FetchNextMessagesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FetchNextMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FetchNextMessagesMock.invocationsDone()
}

// MinimockFetchNextMessagesInspect logs each unmet expectation
func (m *EventRepositoryMock) MinimockFetchNextMessagesInspect() {
	for _, e := range m.FetchNextMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventRepositoryMock.FetchNextMessages at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFetchNextMessagesCounter := mm_atomic.LoadUint64(&m.afterFetchNextMessagesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FetchNextMessagesMock.defaultExpectation != nil && afterFetchNextMessagesCounter < 1 {
		if m.FetchNextMessagesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EventRepositoryMock.FetchNextMessages at\n%s", m.FetchNextMessagesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EventRepositoryMock.FetchNextMessages at\n%s with params: %#v", m.FetchNextMessagesMock.defaultExpectation.expectationOrigins.origin, *m.FetchNextMessagesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchNextMessages != nil && afterFetchNextMessagesCounter < 1 {
		m.t.Errorf("Expected call to EventRepositoryMock.FetchNextMessages at\n%s", m.funcFetchNextMessagesOrigin)
	}

	if !m.FetchNextMessagesMock.invocationsDone() && afterFetchNextMessagesCounter > 0 {
		m.t.Errorf("Expected %d calls to EventRepositoryMock.FetchNextMessages at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FetchNextMessagesMock.expectedInvocations), m.FetchNextMessagesMock.expectedInvocationsOrigin, afterFetchNextMessagesCounter)
	}
}

type mEventRepositoryMockMarkAsError struct {
	optional           bool
	mock               *EventRepositoryMock
	defaultExpectation *EventRepositoryMockMarkAsErrorExpectation
	expectations       []*EventRepositoryMockMarkAsErrorExpectation

	callArgs []*EventRepositoryMockMarkAsErrorParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EventRepositoryMockMarkAsErrorExpectation specifies expectation struct of the eventRepository.MarkAsError
type EventRepositoryMockMarkAsErrorExpectation struct {
	mock               *EventRepositoryMock
	params             *EventRepositoryMockMarkAsErrorParams
	paramPtrs          *EventRepositoryMockMarkAsErrorParamPtrs
	expectationOrigins EventRepositoryMockMarkAsErrorExpectationOrigins
	results            *EventRepositoryMockMarkAsErrorResults
	returnOrigin       string
	Counter            uint64
}

// EventRepositoryMockMarkAsErrorParams contains parameters of the eventRepository.MarkAsError
type EventRepositoryMockMarkAsErrorParams struct {
	ctx      context.Context
	orderIDs []int64
}

// EventRepositoryMockMarkAsErrorParamPtrs contains pointers to parameters of the eventRepository.MarkAsError
type EventRepositoryMockMarkAsErrorParamPtrs struct {
	ctx      *context.Context
	orderIDs *[]int64
}

// EventRepositoryMockMarkAsErrorResults contains results of the eventRepository.MarkAsError
type EventRepositoryMockMarkAsErrorResults struct {
	err error
}

// EventRepositoryMockMarkAsErrorOrigins contains origins of expectations of the eventRepository.MarkAsError
type EventRepositoryMockMarkAsErrorExpectationOrigins struct {
	origin         string
	originCtx      string
	originOrderIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMarkAsError *mEventRepositoryMockMarkAsError) Optional() *mEventRepositoryMockMarkAsError {
	mmMarkAsError.optional = true
	return mmMarkAsError
}

// Expect sets up expected params for eventRepository.MarkAsError
func (mmMarkAsError *mEventRepositoryMockMarkAsError) Expect(ctx context.Context, orderIDs []int64) *mEventRepositoryMockMarkAsError {
	if mmMarkAsError.mock.funcMarkAsError != nil {
		mmMarkAsError.mock.t.Fatalf("EventRepositoryMock.MarkAsError mock is already set by Set")
	}

	if mmMarkAsError.defaultExpectation == nil {
		mmMarkAsError.defaultExpectation = &EventRepositoryMockMarkAsErrorExpectation{}
	}

	if mmMarkAsError.defaultExpectation.paramPtrs != nil {
		mmMarkAsError.mock.t.Fatalf("EventRepositoryMock.MarkAsError mock is already set by ExpectParams functions")
	}

	mmMarkAsError.defaultExpectation.params = &EventRepositoryMockMarkAsErrorParams{ctx, orderIDs}
	mmMarkAsError.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmMarkAsError.expectations {
		if minimock.Equal(e.params, mmMarkAsError.defaultExpectation.params) {
			mmMarkAsError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMarkAsError.defaultExpectation.params)
		}
	}

	return mmMarkAsError
}

// ExpectCtxParam1 sets up expected param ctx for eventRepository.MarkAsError
func (mmMarkAsError *mEventRepositoryMockMarkAsError) ExpectCtxParam1(ctx context.Context) *mEventRepositoryMockMarkAsError {
	if mmMarkAsError.mock.funcMarkAsError != nil {
		mmMarkAsError.mock.t.Fatalf("EventRepositoryMock.MarkAsError mock is already set by Set")
	}

	if mmMarkAsError.defaultExpectation == nil {
		mmMarkAsError.defaultExpectation = &EventRepositoryMockMarkAsErrorExpectation{}
	}

	if mmMarkAsError.defaultExpectation.params != nil {
		mmMarkAsError.mock.t.Fatalf("EventRepositoryMock.MarkAsError mock is already set by Expect")
	}

	if mmMarkAsError.defaultExpectation.paramPtrs == nil {
		mmMarkAsError.defaultExpectation.paramPtrs = &EventRepositoryMockMarkAsErrorParamPtrs{}
	}
	mmMarkAsError.defaultExpectation.paramPtrs.ctx = &ctx
	mmMarkAsError.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmMarkAsError
}

// ExpectOrderIDsParam2 sets up expected param orderIDs for eventRepository.MarkAsError
func (mmMarkAsError *mEventRepositoryMockMarkAsError) ExpectOrderIDsParam2(orderIDs []int64) *mEventRepositoryMockMarkAsError {
	if mmMarkAsError.mock.funcMarkAsError != nil {
		mmMarkAsError.mock.t.Fatalf("EventRepositoryMock.MarkAsError mock is already set by Set")
	}

	if mmMarkAsError.defaultExpectation == nil {
		mmMarkAsError.defaultExpectation = &EventRepositoryMockMarkAsErrorExpectation{}
	}

	if mmMarkAsError.defaultExpectation.params != nil {
		mmMarkAsError.mock.t.Fatalf("EventRepositoryMock.MarkAsError mock is already set by Expect")
	}

	if mmMarkAsError.defaultExpectation.paramPtrs == nil {
		mmMarkAsError.defaultExpectation.paramPtrs = &EventRepositoryMockMarkAsErrorParamPtrs{}
	}
	mmMarkAsError.defaultExpectation.paramPtrs.orderIDs = &orderIDs
	mmMarkAsError.defaultExpectation.expectationOrigins.originOrderIDs = minimock.CallerInfo(1)

	return mmMarkAsError
}

// Inspect accepts an inspector function that has same arguments as the eventRepository.MarkAsError
func (mmMarkAsError *mEventRepositoryMockMarkAsError) Inspect(f func(ctx context.Context, orderIDs []int64)) *mEventRepositoryMockMarkAsError {
	if mmMarkAsError.mock.inspectFuncMarkAsError != nil {
		mmMarkAsError.mock.t.Fatalf("Inspect function is already set for EventRepositoryMock.MarkAsError")
	}

	mmMarkAsError.mock.inspectFuncMarkAsError = f

	return mmMarkAsError
}

// Return sets up results that will be returned by eventRepository.MarkAsError
func (mmMarkAsError *mEventRepositoryMockMarkAsError) Return(err error) *EventRepositoryMock {
	if mmMarkAsError.mock.funcMarkAsError != nil {
		mmMarkAsError.mock.t.Fatalf("EventRepositoryMock.MarkAsError mock is already set by Set")
	}

	if mmMarkAsError.defaultExpectation == nil {
		mmMarkAsError.defaultExpectation = &EventRepositoryMockMarkAsErrorExpectation{mock: mmMarkAsError.mock}
	}
	mmMarkAsError.defaultExpectation.results = &EventRepositoryMockMarkAsErrorResults{err}
	mmMarkAsError.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmMarkAsError.mock
}

// Set uses given function f to mock the eventRepository.MarkAsError method
func (mmMarkAsError *mEventRepositoryMockMarkAsError) Set(f func(ctx context.Context, orderIDs []int64) (err error)) *EventRepositoryMock {
	if mmMarkAsError.defaultExpectation != nil {
		mmMarkAsError.mock.t.Fatalf("Default expectation is already set for the eventRepository.MarkAsError method")
	}

	if len(mmMarkAsError.expectations) > 0 {
		mmMarkAsError.mock.t.Fatalf("Some expectations are already set for the eventRepository.MarkAsError method")
	}

	mmMarkAsError.mock.funcMarkAsError = f
	mmMarkAsError.mock.funcMarkAsErrorOrigin = minimock.CallerInfo(1)
	return mmMarkAsError.mock
}

// When sets expectation for the eventRepository.MarkAsError which will trigger the result defined by the following
// Then helper
func (mmMarkAsError *mEventRepositoryMockMarkAsError) When(ctx context.Context, orderIDs []int64) *EventRepositoryMockMarkAsErrorExpectation {
	if mmMarkAsError.mock.funcMarkAsError != nil {
		mmMarkAsError.mock.t.Fatalf("EventRepositoryMock.MarkAsError mock is already set by Set")
	}

	expectation := &EventRepositoryMockMarkAsErrorExpectation{
		mock:               mmMarkAsError.mock,
		params:             &EventRepositoryMockMarkAsErrorParams{ctx, orderIDs},
		expectationOrigins: EventRepositoryMockMarkAsErrorExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmMarkAsError.expectations = append(mmMarkAsError.expectations, expectation)
	return expectation
}

// Then sets up eventRepository.MarkAsError return parameters for the expectation previously defined by the When method
func (e *EventRepositoryMockMarkAsErrorExpectation) Then(err error) *EventRepositoryMock {
	e.results = &EventRepositoryMockMarkAsErrorResults{err}
	return e.mock
}

// Times sets number of times eventRepository.MarkAsError should be invoked
func (mmMarkAsError *mEventRepositoryMockMarkAsError) Times(n uint64) *mEventRepositoryMockMarkAsError {
	if n == 0 {
		mmMarkAsError.mock.t.Fatalf("Times of EventRepositoryMock.MarkAsError mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMarkAsError.expectedInvocations, n)
	mmMarkAsError.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmMarkAsError
}

func (mmMarkAsError *mEventRepositoryMockMarkAsError) invocationsDone() bool {
	if len(mmMarkAsError.expectations) == 0 && mmMarkAsError.defaultExpectation == nil && mmMarkAsError.mock.funcMarkAsError == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMarkAsError.mock.afterMarkAsErrorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMarkAsError.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// MarkAsError implements mm_orderevent.eventRepository
func (mmMarkAsError *EventRepositoryMock) MarkAsError(ctx context.Context, orderIDs []int64) (err error) {
	mm_atomic.AddUint64(&mmMarkAsError.beforeMarkAsErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmMarkAsError.afterMarkAsErrorCounter, 1)

	mmMarkAsError.t.Helper()

	if mmMarkAsError.inspectFuncMarkAsError != nil {
		mmMarkAsError.inspectFuncMarkAsError(ctx, orderIDs)
	}

	mm_params := EventRepositoryMockMarkAsErrorParams{ctx, orderIDs}

	// Record call args
	mmMarkAsError.MarkAsErrorMock.mutex.Lock()
	mmMarkAsError.MarkAsErrorMock.callArgs = append(mmMarkAsError.MarkAsErrorMock.callArgs, &mm_params)
	mmMarkAsError.MarkAsErrorMock.mutex.Unlock()

	for _, e := range mmMarkAsError.MarkAsErrorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMarkAsError.MarkAsErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMarkAsError.MarkAsErrorMock.defaultExpectation.Counter, 1)
		mm_want := mmMarkAsError.MarkAsErrorMock.defaultExpectation.params
		mm_want_ptrs := mmMarkAsError.MarkAsErrorMock.defaultExpectation.paramPtrs

		mm_got := EventRepositoryMockMarkAsErrorParams{ctx, orderIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmMarkAsError.t.Errorf("EventRepositoryMock.MarkAsError got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMarkAsError.MarkAsErrorMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderIDs != nil && !minimock.Equal(*mm_want_ptrs.orderIDs, mm_got.orderIDs) {
				mmMarkAsError.t.Errorf("EventRepositoryMock.MarkAsError got unexpected parameter orderIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMarkAsError.MarkAsErrorMock.defaultExpectation.expectationOrigins.originOrderIDs, *mm_want_ptrs.orderIDs, mm_got.orderIDs, minimock.Diff(*mm_want_ptrs.orderIDs, mm_got.orderIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMarkAsError.t.Errorf("EventRepositoryMock.MarkAsError got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmMarkAsError.MarkAsErrorMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMarkAsError.MarkAsErrorMock.defaultExpectation.results
		if mm_results == nil {
			mmMarkAsError.t.Fatal("No results are set for the EventRepositoryMock.MarkAsError")
		}
		return (*mm_results).err
	}
	if mmMarkAsError.funcMarkAsError != nil {
		return mmMarkAsError.funcMarkAsError(ctx, orderIDs)
	}
	mmMarkAsError.t.Fatalf("Unexpected call to EventRepositoryMock.MarkAsError. %v %v", ctx, orderIDs)
	return
}

// MarkAsErrorAfterCounter returns a count of finished EventRepositoryMock.MarkAsError invocations
func (mmMarkAsError *EventRepositoryMock) MarkAsErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkAsError.afterMarkAsErrorCounter)
}

// MarkAsErrorBeforeCounter returns a count of EventRepositoryMock.MarkAsError invocations
func (mmMarkAsError *EventRepositoryMock) MarkAsErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkAsError.beforeMarkAsErrorCounter)
}

// Calls returns a list of arguments used in each call to EventRepositoryMock.MarkAsError.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMarkAsError *mEventRepositoryMockMarkAsError) Calls() []*EventRepositoryMockMarkAsErrorParams {
	mmMarkAsError.mutex.RLock()

	argCopy := make([]*EventRepositoryMockMarkAsErrorParams, len(mmMarkAsError.callArgs))
	copy(argCopy, mmMarkAsError.callArgs)

	mmMarkAsError.mutex.RUnlock()

	return argCopy
}

// MinimockMarkAsErrorDone returns true if the count of the MarkAsError invocations corresponds
// the number of defined expectations
func (m *EventRepositoryMock) MinimockMarkAsErrorDone() bool {
	if m.MarkAsErrorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.MarkAsErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MarkAsErrorMock.invocationsDone()
}

// MinimockMarkAsErrorInspect logs each unmet expectation
func (m *EventRepositoryMock) MinimockMarkAsErrorInspect() {
	for _, e := range m.MarkAsErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventRepositoryMock.MarkAsError at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterMarkAsErrorCounter := mm_atomic.LoadUint64(&m.afterMarkAsErrorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MarkAsErrorMock.defaultExpectation != nil && afterMarkAsErrorCounter < 1 {
		if m.MarkAsErrorMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EventRepositoryMock.MarkAsError at\n%s", m.MarkAsErrorMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EventRepositoryMock.MarkAsError at\n%s with params: %#v", m.MarkAsErrorMock.defaultExpectation.expectationOrigins.origin, *m.MarkAsErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMarkAsError != nil && afterMarkAsErrorCounter < 1 {
		m.t.Errorf("Expected call to EventRepositoryMock.MarkAsError at\n%s", m.funcMarkAsErrorOrigin)
	}

	if !m.MarkAsErrorMock.invocationsDone() && afterMarkAsErrorCounter > 0 {
		m.t.Errorf("Expected %d calls to EventRepositoryMock.MarkAsError at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.MarkAsErrorMock.expectedInvocations), m.MarkAsErrorMock.expectedInvocationsOrigin, afterMarkAsErrorCounter)
	}
}

type mEventRepositoryMockMarkAsSent struct {
	optional           bool
	mock               *EventRepositoryMock
	defaultExpectation *EventRepositoryMockMarkAsSentExpectation
	expectations       []*EventRepositoryMockMarkAsSentExpectation

	callArgs []*EventRepositoryMockMarkAsSentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EventRepositoryMockMarkAsSentExpectation specifies expectation struct of the eventRepository.MarkAsSent
type EventRepositoryMockMarkAsSentExpectation struct {
	mock               *EventRepositoryMock
	params             *EventRepositoryMockMarkAsSentParams
	paramPtrs          *EventRepositoryMockMarkAsSentParamPtrs
	expectationOrigins EventRepositoryMockMarkAsSentExpectationOrigins
	results            *EventRepositoryMockMarkAsSentResults
	returnOrigin       string
	Counter            uint64
}

// EventRepositoryMockMarkAsSentParams contains parameters of the eventRepository.MarkAsSent
type EventRepositoryMockMarkAsSentParams struct {
	ctx context.Context
	ids []int64
}

// EventRepositoryMockMarkAsSentParamPtrs contains pointers to parameters of the eventRepository.MarkAsSent
type EventRepositoryMockMarkAsSentParamPtrs struct {
	ctx *context.Context
	ids *[]int64
}

// EventRepositoryMockMarkAsSentResults contains results of the eventRepository.MarkAsSent
type EventRepositoryMockMarkAsSentResults struct {
	err error
}

// EventRepositoryMockMarkAsSentOrigins contains origins of expectations of the eventRepository.MarkAsSent
type EventRepositoryMockMarkAsSentExpectationOrigins struct {
	origin    string
	originCtx string
	originIds string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMarkAsSent *mEventRepositoryMockMarkAsSent) Optional() *mEventRepositoryMockMarkAsSent {
	mmMarkAsSent.optional = true
	return mmMarkAsSent
}

// Expect sets up expected params for eventRepository.MarkAsSent
func (mmMarkAsSent *mEventRepositoryMockMarkAsSent) Expect(ctx context.Context, ids []int64) *mEventRepositoryMockMarkAsSent {
	if mmMarkAsSent.mock.funcMarkAsSent != nil {
		mmMarkAsSent.mock.t.Fatalf("EventRepositoryMock.MarkAsSent mock is already set by Set")
	}

	if mmMarkAsSent.defaultExpectation == nil {
		mmMarkAsSent.defaultExpectation = &EventRepositoryMockMarkAsSentExpectation{}
	}

	if mmMarkAsSent.defaultExpectation.paramPtrs != nil {
		mmMarkAsSent.mock.t.Fatalf("EventRepositoryMock.MarkAsSent mock is already set by ExpectParams functions")
	}

	mmMarkAsSent.defaultExpectation.params = &EventRepositoryMockMarkAsSentParams{ctx, ids}
	mmMarkAsSent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmMarkAsSent.expectations {
		if minimock.Equal(e.params, mmMarkAsSent.defaultExpectation.params) {
			mmMarkAsSent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMarkAsSent.defaultExpectation.params)
		}
	}

	return mmMarkAsSent
}

// ExpectCtxParam1 sets up expected param ctx for eventRepository.MarkAsSent
func (mmMarkAsSent *mEventRepositoryMockMarkAsSent) ExpectCtxParam1(ctx context.Context) *mEventRepositoryMockMarkAsSent {
	if mmMarkAsSent.mock.funcMarkAsSent != nil {
		mmMarkAsSent.mock.t.Fatalf("EventRepositoryMock.MarkAsSent mock is already set by Set")
	}

	if mmMarkAsSent.defaultExpectation == nil {
		mmMarkAsSent.defaultExpectation = &EventRepositoryMockMarkAsSentExpectation{}
	}

	if mmMarkAsSent.defaultExpectation.params != nil {
		mmMarkAsSent.mock.t.Fatalf("EventRepositoryMock.MarkAsSent mock is already set by Expect")
	}

	if mmMarkAsSent.defaultExpectation.paramPtrs == nil {
		mmMarkAsSent.defaultExpectation.paramPtrs = &EventRepositoryMockMarkAsSentParamPtrs{}
	}
	mmMarkAsSent.defaultExpectation.paramPtrs.ctx = &ctx
	mmMarkAsSent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmMarkAsSent
}

// ExpectIdsParam2 sets up expected param ids for eventRepository.MarkAsSent
func (mmMarkAsSent *mEventRepositoryMockMarkAsSent) ExpectIdsParam2(ids []int64) *mEventRepositoryMockMarkAsSent {
	if mmMarkAsSent.mock.funcMarkAsSent != nil {
		mmMarkAsSent.mock.t.Fatalf("EventRepositoryMock.MarkAsSent mock is already set by Set")
	}

	if mmMarkAsSent.defaultExpectation == nil {
		mmMarkAsSent.defaultExpectation = &EventRepositoryMockMarkAsSentExpectation{}
	}

	if mmMarkAsSent.defaultExpectation.params != nil {
		mmMarkAsSent.mock.t.Fatalf("EventRepositoryMock.MarkAsSent mock is already set by Expect")
	}

	if mmMarkAsSent.defaultExpectation.paramPtrs == nil {
		mmMarkAsSent.defaultExpectation.paramPtrs = &EventRepositoryMockMarkAsSentParamPtrs{}
	}
	mmMarkAsSent.defaultExpectation.paramPtrs.ids = &ids
	mmMarkAsSent.defaultExpectation.expectationOrigins.originIds = minimock.CallerInfo(1)

	return mmMarkAsSent
}

// Inspect accepts an inspector function that has same arguments as the eventRepository.MarkAsSent
func (mmMarkAsSent *mEventRepositoryMockMarkAsSent) Inspect(f func(ctx context.Context, ids []int64)) *mEventRepositoryMockMarkAsSent {
	if mmMarkAsSent.mock.inspectFuncMarkAsSent != nil {
		mmMarkAsSent.mock.t.Fatalf("Inspect function is already set for EventRepositoryMock.MarkAsSent")
	}

	mmMarkAsSent.mock.inspectFuncMarkAsSent = f

	return mmMarkAsSent
}

// Return sets up results that will be returned by eventRepository.MarkAsSent
func (mmMarkAsSent *mEventRepositoryMockMarkAsSent) Return(err error) *EventRepositoryMock {
	if mmMarkAsSent.mock.funcMarkAsSent != nil {
		mmMarkAsSent.mock.t.Fatalf("EventRepositoryMock.MarkAsSent mock is already set by Set")
	}

	if mmMarkAsSent.defaultExpectation == nil {
		mmMarkAsSent.defaultExpectation = &EventRepositoryMockMarkAsSentExpectation{mock: mmMarkAsSent.mock}
	}
	mmMarkAsSent.defaultExpectation.results = &EventRepositoryMockMarkAsSentResults{err}
	mmMarkAsSent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmMarkAsSent.mock
}

// Set uses given function f to mock the eventRepository.MarkAsSent method
func (mmMarkAsSent *mEventRepositoryMockMarkAsSent) Set(f func(ctx context.Context, ids []int64) (err error)) *EventRepositoryMock {
	if mmMarkAsSent.defaultExpectation != nil {
		mmMarkAsSent.mock.t.Fatalf("Default expectation is already set for the eventRepository.MarkAsSent method")
	}

	if len(mmMarkAsSent.expectations) > 0 {
		mmMarkAsSent.mock.t.Fatalf("Some expectations are already set for the eventRepository.MarkAsSent method")
	}

	mmMarkAsSent.mock.funcMarkAsSent = f
	mmMarkAsSent.mock.funcMarkAsSentOrigin = minimock.CallerInfo(1)
	return mmMarkAsSent.mock
}

// When sets expectation for the eventRepository.MarkAsSent which will trigger the result defined by the following
// Then helper
func (mmMarkAsSent *mEventRepositoryMockMarkAsSent) When(ctx context.Context, ids []int64) *EventRepositoryMockMarkAsSentExpectation {
	if mmMarkAsSent.mock.funcMarkAsSent != nil {
		mmMarkAsSent.mock.t.Fatalf("EventRepositoryMock.MarkAsSent mock is already set by Set")
	}

	expectation := &EventRepositoryMockMarkAsSentExpectation{
		mock:               mmMarkAsSent.mock,
		params:             &EventRepositoryMockMarkAsSentParams{ctx, ids},
		expectationOrigins: EventRepositoryMockMarkAsSentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmMarkAsSent.expectations = append(mmMarkAsSent.expectations, expectation)
	return expectation
}

// Then sets up eventRepository.MarkAsSent return parameters for the expectation previously defined by the When method
func (e *EventRepositoryMockMarkAsSentExpectation) Then(err error) *EventRepositoryMock {
	e.results = &EventRepositoryMockMarkAsSentResults{err}
	return e.mock
}

// Times sets number of times eventRepository.MarkAsSent should be invoked
func (mmMarkAsSent *mEventRepositoryMockMarkAsSent) Times(n uint64) *mEventRepositoryMockMarkAsSent {
	if n == 0 {
		mmMarkAsSent.mock.t.Fatalf("Times of EventRepositoryMock.MarkAsSent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMarkAsSent.expectedInvocations, n)
	mmMarkAsSent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmMarkAsSent
}

func (mmMarkAsSent *mEventRepositoryMockMarkAsSent) invocationsDone() bool {
	if len(mmMarkAsSent.expectations) == 0 && mmMarkAsSent.defaultExpectation == nil && mmMarkAsSent.mock.funcMarkAsSent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMarkAsSent.mock.afterMarkAsSentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMarkAsSent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// MarkAsSent implements mm_orderevent.eventRepository
func (mmMarkAsSent *EventRepositoryMock) MarkAsSent(ctx context.Context, ids []int64) (err error) {
	mm_atomic.AddUint64(&mmMarkAsSent.beforeMarkAsSentCounter, 1)
	defer mm_atomic.AddUint64(&mmMarkAsSent.afterMarkAsSentCounter, 1)

	mmMarkAsSent.t.Helper()

	if mmMarkAsSent.inspectFuncMarkAsSent != nil {
		mmMarkAsSent.inspectFuncMarkAsSent(ctx, ids)
	}

	mm_params := EventRepositoryMockMarkAsSentParams{ctx, ids}

	// Record call args
	mmMarkAsSent.MarkAsSentMock.mutex.Lock()
	mmMarkAsSent.MarkAsSentMock.callArgs = append(mmMarkAsSent.MarkAsSentMock.callArgs, &mm_params)
	mmMarkAsSent.MarkAsSentMock.mutex.Unlock()

	for _, e := range mmMarkAsSent.MarkAsSentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMarkAsSent.MarkAsSentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMarkAsSent.MarkAsSentMock.defaultExpectation.Counter, 1)
		mm_want := mmMarkAsSent.MarkAsSentMock.defaultExpectation.params
		mm_want_ptrs := mmMarkAsSent.MarkAsSentMock.defaultExpectation.paramPtrs

		mm_got := EventRepositoryMockMarkAsSentParams{ctx, ids}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmMarkAsSent.t.Errorf("EventRepositoryMock.MarkAsSent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMarkAsSent.MarkAsSentMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ids != nil && !minimock.Equal(*mm_want_ptrs.ids, mm_got.ids) {
				mmMarkAsSent.t.Errorf("EventRepositoryMock.MarkAsSent got unexpected parameter ids, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMarkAsSent.MarkAsSentMock.defaultExpectation.expectationOrigins.originIds, *mm_want_ptrs.ids, mm_got.ids, minimock.Diff(*mm_want_ptrs.ids, mm_got.ids))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMarkAsSent.t.Errorf("EventRepositoryMock.MarkAsSent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmMarkAsSent.MarkAsSentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMarkAsSent.MarkAsSentMock.defaultExpectation.results
		if mm_results == nil {
			mmMarkAsSent.t.Fatal("No results are set for the EventRepositoryMock.MarkAsSent")
		}
		return (*mm_results).err
	}
	if mmMarkAsSent.funcMarkAsSent != nil {
		return mmMarkAsSent.funcMarkAsSent(ctx, ids)
	}
	mmMarkAsSent.t.Fatalf("Unexpected call to EventRepositoryMock.MarkAsSent. %v %v", ctx, ids)
	return
}

// MarkAsSentAfterCounter returns a count of finished EventRepositoryMock.MarkAsSent invocations
func (mmMarkAsSent *EventRepositoryMock) MarkAsSentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkAsSent.afterMarkAsSentCounter)
}

// MarkAsSentBeforeCounter returns a count of EventRepositoryMock.MarkAsSent invocations
func (mmMarkAsSent *EventRepositoryMock) MarkAsSentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkAsSent.beforeMarkAsSentCounter)
}

// Calls returns a list of arguments used in each call to EventRepositoryMock.MarkAsSent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMarkAsSent *mEventRepositoryMockMarkAsSent) Calls() []*EventRepositoryMockMarkAsSentParams {
	mmMarkAsSent.mutex.RLock()

	argCopy := make([]*EventRepositoryMockMarkAsSentParams, len(mmMarkAsSent.callArgs))
	copy(argCopy, mmMarkAsSent.callArgs)

	mmMarkAsSent.mutex.RUnlock()

	return argCopy
}

// MinimockMarkAsSentDone returns true if the count of the MarkAsSent invocations corresponds
// the number of defined expectations
func (m *EventRepositoryMock) MinimockMarkAsSentDone() bool {
	if m.MarkAsSentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.MarkAsSentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MarkAsSentMock.invocationsDone()
}

// MinimockMarkAsSentInspect logs each unmet expectation
func (m *EventRepositoryMock) MinimockMarkAsSentInspect() {
	for _, e := range m.MarkAsSentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventRepositoryMock.MarkAsSent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterMarkAsSentCounter := mm_atomic.LoadUint64(&m.afterMarkAsSentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MarkAsSentMock.defaultExpectation != nil && afterMarkAsSentCounter < 1 {
		if m.MarkAsSentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EventRepositoryMock.MarkAsSent at\n%s", m.MarkAsSentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EventRepositoryMock.MarkAsSent at\n%s with params: %#v", m.MarkAsSentMock.defaultExpectation.expectationOrigins.origin, *m.MarkAsSentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMarkAsSent != nil && afterMarkAsSentCounter < 1 {
		m.t.Errorf("Expected call to EventRepositoryMock.MarkAsSent at\n%s", m.funcMarkAsSentOrigin)
	}

	if !m.MarkAsSentMock.invocationsDone() && afterMarkAsSentCounter > 0 {
		m.t.Errorf("Expected %d calls to EventRepositoryMock.MarkAsSent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.MarkAsSentMock.expectedInvocations), m.MarkAsSentMock.expectedInvocationsOrigin, afterMarkAsSentCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *EventRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockFetchNextMessagesInspect()

			m.MinimockMarkAsErrorInspect()

			m.MinimockMarkAsSentInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *EventRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *EventRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockFetchNextMessagesDone() &&
		m.MinimockMarkAsErrorDone() &&
		m.MinimockMarkAsSentDone()
}
