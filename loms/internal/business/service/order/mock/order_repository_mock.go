// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	"context"
	"route256/loms/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OrderRepositoryMock implements mm_order.orderRepository
type OrderRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateOrder          func(ctx context.Context, userID int64) (i1 int64, err error)
	funcCreateOrderOrigin    string
	inspectFuncCreateOrder   func(ctx context.Context, userID int64)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mOrderRepositoryMockCreateOrder

	funcCreateOrderItems          func(ctx context.Context, orderID int64, items []domain.Item) (err error)
	funcCreateOrderItemsOrigin    string
	inspectFuncCreateOrderItems   func(ctx context.Context, orderID int64, items []domain.Item)
	afterCreateOrderItemsCounter  uint64
	beforeCreateOrderItemsCounter uint64
	CreateOrderItemsMock          mOrderRepositoryMockCreateOrderItems

	funcGetByOrderID          func(ctx context.Context, orderID int64) (o1 domain.Order, err error)
	funcGetByOrderIDOrigin    string
	inspectFuncGetByOrderID   func(ctx context.Context, orderID int64)
	afterGetByOrderIDCounter  uint64
	beforeGetByOrderIDCounter uint64
	GetByOrderIDMock          mOrderRepositoryMockGetByOrderID

	funcGetByOrderIDForUpdate          func(ctx context.Context, orderID int64) (o1 domain.Order, err error)
	funcGetByOrderIDForUpdateOrigin    string
	inspectFuncGetByOrderIDForUpdate   func(ctx context.Context, orderID int64)
	afterGetByOrderIDForUpdateCounter  uint64
	beforeGetByOrderIDForUpdateCounter uint64
	GetByOrderIDForUpdateMock          mOrderRepositoryMockGetByOrderIDForUpdate

	funcSetStatus          func(ctx context.Context, orderID int64, status domain.OrderStatus) (err error)
	funcSetStatusOrigin    string
	inspectFuncSetStatus   func(ctx context.Context, orderID int64, status domain.OrderStatus)
	afterSetStatusCounter  uint64
	beforeSetStatusCounter uint64
	SetStatusMock          mOrderRepositoryMockSetStatus

	funcSetStatusAndCreateEvent          func(ctx context.Context, orderID int64, status domain.OrderStatus, event domain.Event) (err error)
	funcSetStatusAndCreateEventOrigin    string
	inspectFuncSetStatusAndCreateEvent   func(ctx context.Context, orderID int64, status domain.OrderStatus, event domain.Event)
	afterSetStatusAndCreateEventCounter  uint64
	beforeSetStatusAndCreateEventCounter uint64
	SetStatusAndCreateEventMock          mOrderRepositoryMockSetStatusAndCreateEvent
}

// NewOrderRepositoryMock returns a mock for mm_order.orderRepository
func NewOrderRepositoryMock(t minimock.Tester) *OrderRepositoryMock {
	m := &OrderRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateOrderMock = mOrderRepositoryMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*OrderRepositoryMockCreateOrderParams{}

	m.CreateOrderItemsMock = mOrderRepositoryMockCreateOrderItems{mock: m}
	m.CreateOrderItemsMock.callArgs = []*OrderRepositoryMockCreateOrderItemsParams{}

	m.GetByOrderIDMock = mOrderRepositoryMockGetByOrderID{mock: m}
	m.GetByOrderIDMock.callArgs = []*OrderRepositoryMockGetByOrderIDParams{}

	m.GetByOrderIDForUpdateMock = mOrderRepositoryMockGetByOrderIDForUpdate{mock: m}
	m.GetByOrderIDForUpdateMock.callArgs = []*OrderRepositoryMockGetByOrderIDForUpdateParams{}

	m.SetStatusMock = mOrderRepositoryMockSetStatus{mock: m}
	m.SetStatusMock.callArgs = []*OrderRepositoryMockSetStatusParams{}

	m.SetStatusAndCreateEventMock = mOrderRepositoryMockSetStatusAndCreateEvent{mock: m}
	m.SetStatusAndCreateEventMock.callArgs = []*OrderRepositoryMockSetStatusAndCreateEventParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderRepositoryMockCreateOrder struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockCreateOrderExpectation
	expectations       []*OrderRepositoryMockCreateOrderExpectation

	callArgs []*OrderRepositoryMockCreateOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockCreateOrderExpectation specifies expectation struct of the orderRepository.CreateOrder
type OrderRepositoryMockCreateOrderExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockCreateOrderParams
	paramPtrs          *OrderRepositoryMockCreateOrderParamPtrs
	expectationOrigins OrderRepositoryMockCreateOrderExpectationOrigins
	results            *OrderRepositoryMockCreateOrderResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockCreateOrderParams contains parameters of the orderRepository.CreateOrder
type OrderRepositoryMockCreateOrderParams struct {
	ctx    context.Context
	userID int64
}

// OrderRepositoryMockCreateOrderParamPtrs contains pointers to parameters of the orderRepository.CreateOrder
type OrderRepositoryMockCreateOrderParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// OrderRepositoryMockCreateOrderResults contains results of the orderRepository.CreateOrder
type OrderRepositoryMockCreateOrderResults struct {
	i1  int64
	err error
}

// OrderRepositoryMockCreateOrderOrigins contains origins of expectations of the orderRepository.CreateOrder
type OrderRepositoryMockCreateOrderExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateOrder *mOrderRepositoryMockCreateOrder) Optional() *mOrderRepositoryMockCreateOrder {
	mmCreateOrder.optional = true
	return mmCreateOrder
}

// Expect sets up expected params for orderRepository.CreateOrder
func (mmCreateOrder *mOrderRepositoryMockCreateOrder) Expect(ctx context.Context, userID int64) *mOrderRepositoryMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrderRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &OrderRepositoryMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.paramPtrs != nil {
		mmCreateOrder.mock.t.Fatalf("OrderRepositoryMock.CreateOrder mock is already set by ExpectParams functions")
	}

	mmCreateOrder.defaultExpectation.params = &OrderRepositoryMockCreateOrderParams{ctx, userID}
	mmCreateOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// ExpectCtxParam1 sets up expected param ctx for orderRepository.CreateOrder
func (mmCreateOrder *mOrderRepositoryMockCreateOrder) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrderRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &OrderRepositoryMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.params != nil {
		mmCreateOrder.mock.t.Fatalf("OrderRepositoryMock.CreateOrder mock is already set by Expect")
	}

	if mmCreateOrder.defaultExpectation.paramPtrs == nil {
		mmCreateOrder.defaultExpectation.paramPtrs = &OrderRepositoryMockCreateOrderParamPtrs{}
	}
	mmCreateOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateOrder
}

// ExpectUserIDParam2 sets up expected param userID for orderRepository.CreateOrder
func (mmCreateOrder *mOrderRepositoryMockCreateOrder) ExpectUserIDParam2(userID int64) *mOrderRepositoryMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrderRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &OrderRepositoryMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.params != nil {
		mmCreateOrder.mock.t.Fatalf("OrderRepositoryMock.CreateOrder mock is already set by Expect")
	}

	if mmCreateOrder.defaultExpectation.paramPtrs == nil {
		mmCreateOrder.defaultExpectation.paramPtrs = &OrderRepositoryMockCreateOrderParamPtrs{}
	}
	mmCreateOrder.defaultExpectation.paramPtrs.userID = &userID
	mmCreateOrder.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the orderRepository.CreateOrder
func (mmCreateOrder *mOrderRepositoryMockCreateOrder) Inspect(f func(ctx context.Context, userID int64)) *mOrderRepositoryMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by orderRepository.CreateOrder
func (mmCreateOrder *mOrderRepositoryMockCreateOrder) Return(i1 int64, err error) *OrderRepositoryMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrderRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &OrderRepositoryMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &OrderRepositoryMockCreateOrderResults{i1, err}
	mmCreateOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateOrder.mock
}

// Set uses given function f to mock the orderRepository.CreateOrder method
func (mmCreateOrder *mOrderRepositoryMockCreateOrder) Set(f func(ctx context.Context, userID int64) (i1 int64, err error)) *OrderRepositoryMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the orderRepository.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the orderRepository.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	mmCreateOrder.mock.funcCreateOrderOrigin = minimock.CallerInfo(1)
	return mmCreateOrder.mock
}

// When sets expectation for the orderRepository.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mOrderRepositoryMockCreateOrder) When(ctx context.Context, userID int64) *OrderRepositoryMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrderRepositoryMock.CreateOrder mock is already set by Set")
	}

	expectation := &OrderRepositoryMockCreateOrderExpectation{
		mock:               mmCreateOrder.mock,
		params:             &OrderRepositoryMockCreateOrderParams{ctx, userID},
		expectationOrigins: OrderRepositoryMockCreateOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up orderRepository.CreateOrder return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockCreateOrderExpectation) Then(i1 int64, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockCreateOrderResults{i1, err}
	return e.mock
}

// Times sets number of times orderRepository.CreateOrder should be invoked
func (mmCreateOrder *mOrderRepositoryMockCreateOrder) Times(n uint64) *mOrderRepositoryMockCreateOrder {
	if n == 0 {
		mmCreateOrder.mock.t.Fatalf("Times of OrderRepositoryMock.CreateOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateOrder.expectedInvocations, n)
	mmCreateOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateOrder
}

func (mmCreateOrder *mOrderRepositoryMockCreateOrder) invocationsDone() bool {
	if len(mmCreateOrder.expectations) == 0 && mmCreateOrder.defaultExpectation == nil && mmCreateOrder.mock.funcCreateOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateOrder.mock.afterCreateOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateOrder implements mm_order.orderRepository
func (mmCreateOrder *OrderRepositoryMock) CreateOrder(ctx context.Context, userID int64) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	mmCreateOrder.t.Helper()

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, userID)
	}

	mm_params := OrderRepositoryMockCreateOrderParams{ctx, userID}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, &mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_want_ptrs := mmCreateOrder.CreateOrderMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockCreateOrderParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateOrder.t.Errorf("OrderRepositoryMock.CreateOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmCreateOrder.t.Errorf("OrderRepositoryMock.CreateOrder got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("OrderRepositoryMock.CreateOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the OrderRepositoryMock.CreateOrder")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, userID)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to OrderRepositoryMock.CreateOrder. %v %v", ctx, userID)
	return
}

// CreateOrderAfterCounter returns a count of finished OrderRepositoryMock.CreateOrder invocations
func (mmCreateOrder *OrderRepositoryMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of OrderRepositoryMock.CreateOrder invocations
func (mmCreateOrder *OrderRepositoryMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mOrderRepositoryMockCreateOrder) Calls() []*OrderRepositoryMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockCreateOrderDone() bool {
	if m.CreateOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateOrderMock.invocationsDone()
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.CreateOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateOrderCounter := mm_atomic.LoadUint64(&m.afterCreateOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && afterCreateOrderCounter < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.CreateOrder at\n%s", m.CreateOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.CreateOrder at\n%s with params: %#v", m.CreateOrderMock.defaultExpectation.expectationOrigins.origin, *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && afterCreateOrderCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.CreateOrder at\n%s", m.funcCreateOrderOrigin)
	}

	if !m.CreateOrderMock.invocationsDone() && afterCreateOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.CreateOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateOrderMock.expectedInvocations), m.CreateOrderMock.expectedInvocationsOrigin, afterCreateOrderCounter)
	}
}

type mOrderRepositoryMockCreateOrderItems struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockCreateOrderItemsExpectation
	expectations       []*OrderRepositoryMockCreateOrderItemsExpectation

	callArgs []*OrderRepositoryMockCreateOrderItemsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockCreateOrderItemsExpectation specifies expectation struct of the orderRepository.CreateOrderItems
type OrderRepositoryMockCreateOrderItemsExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockCreateOrderItemsParams
	paramPtrs          *OrderRepositoryMockCreateOrderItemsParamPtrs
	expectationOrigins OrderRepositoryMockCreateOrderItemsExpectationOrigins
	results            *OrderRepositoryMockCreateOrderItemsResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockCreateOrderItemsParams contains parameters of the orderRepository.CreateOrderItems
type OrderRepositoryMockCreateOrderItemsParams struct {
	ctx     context.Context
	orderID int64
	items   []domain.Item
}

// OrderRepositoryMockCreateOrderItemsParamPtrs contains pointers to parameters of the orderRepository.CreateOrderItems
type OrderRepositoryMockCreateOrderItemsParamPtrs struct {
	ctx     *context.Context
	orderID *int64
	items   *[]domain.Item
}

// OrderRepositoryMockCreateOrderItemsResults contains results of the orderRepository.CreateOrderItems
type OrderRepositoryMockCreateOrderItemsResults struct {
	err error
}

// OrderRepositoryMockCreateOrderItemsOrigins contains origins of expectations of the orderRepository.CreateOrderItems
type OrderRepositoryMockCreateOrderItemsExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
	originItems   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateOrderItems *mOrderRepositoryMockCreateOrderItems) Optional() *mOrderRepositoryMockCreateOrderItems {
	mmCreateOrderItems.optional = true
	return mmCreateOrderItems
}

// Expect sets up expected params for orderRepository.CreateOrderItems
func (mmCreateOrderItems *mOrderRepositoryMockCreateOrderItems) Expect(ctx context.Context, orderID int64, items []domain.Item) *mOrderRepositoryMockCreateOrderItems {
	if mmCreateOrderItems.mock.funcCreateOrderItems != nil {
		mmCreateOrderItems.mock.t.Fatalf("OrderRepositoryMock.CreateOrderItems mock is already set by Set")
	}

	if mmCreateOrderItems.defaultExpectation == nil {
		mmCreateOrderItems.defaultExpectation = &OrderRepositoryMockCreateOrderItemsExpectation{}
	}

	if mmCreateOrderItems.defaultExpectation.paramPtrs != nil {
		mmCreateOrderItems.mock.t.Fatalf("OrderRepositoryMock.CreateOrderItems mock is already set by ExpectParams functions")
	}

	mmCreateOrderItems.defaultExpectation.params = &OrderRepositoryMockCreateOrderItemsParams{ctx, orderID, items}
	mmCreateOrderItems.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateOrderItems.expectations {
		if minimock.Equal(e.params, mmCreateOrderItems.defaultExpectation.params) {
			mmCreateOrderItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrderItems.defaultExpectation.params)
		}
	}

	return mmCreateOrderItems
}

// ExpectCtxParam1 sets up expected param ctx for orderRepository.CreateOrderItems
func (mmCreateOrderItems *mOrderRepositoryMockCreateOrderItems) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockCreateOrderItems {
	if mmCreateOrderItems.mock.funcCreateOrderItems != nil {
		mmCreateOrderItems.mock.t.Fatalf("OrderRepositoryMock.CreateOrderItems mock is already set by Set")
	}

	if mmCreateOrderItems.defaultExpectation == nil {
		mmCreateOrderItems.defaultExpectation = &OrderRepositoryMockCreateOrderItemsExpectation{}
	}

	if mmCreateOrderItems.defaultExpectation.params != nil {
		mmCreateOrderItems.mock.t.Fatalf("OrderRepositoryMock.CreateOrderItems mock is already set by Expect")
	}

	if mmCreateOrderItems.defaultExpectation.paramPtrs == nil {
		mmCreateOrderItems.defaultExpectation.paramPtrs = &OrderRepositoryMockCreateOrderItemsParamPtrs{}
	}
	mmCreateOrderItems.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateOrderItems.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateOrderItems
}

// ExpectOrderIDParam2 sets up expected param orderID for orderRepository.CreateOrderItems
func (mmCreateOrderItems *mOrderRepositoryMockCreateOrderItems) ExpectOrderIDParam2(orderID int64) *mOrderRepositoryMockCreateOrderItems {
	if mmCreateOrderItems.mock.funcCreateOrderItems != nil {
		mmCreateOrderItems.mock.t.Fatalf("OrderRepositoryMock.CreateOrderItems mock is already set by Set")
	}

	if mmCreateOrderItems.defaultExpectation == nil {
		mmCreateOrderItems.defaultExpectation = &OrderRepositoryMockCreateOrderItemsExpectation{}
	}

	if mmCreateOrderItems.defaultExpectation.params != nil {
		mmCreateOrderItems.mock.t.Fatalf("OrderRepositoryMock.CreateOrderItems mock is already set by Expect")
	}

	if mmCreateOrderItems.defaultExpectation.paramPtrs == nil {
		mmCreateOrderItems.defaultExpectation.paramPtrs = &OrderRepositoryMockCreateOrderItemsParamPtrs{}
	}
	mmCreateOrderItems.defaultExpectation.paramPtrs.orderID = &orderID
	mmCreateOrderItems.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmCreateOrderItems
}

// ExpectItemsParam3 sets up expected param items for orderRepository.CreateOrderItems
func (mmCreateOrderItems *mOrderRepositoryMockCreateOrderItems) ExpectItemsParam3(items []domain.Item) *mOrderRepositoryMockCreateOrderItems {
	if mmCreateOrderItems.mock.funcCreateOrderItems != nil {
		mmCreateOrderItems.mock.t.Fatalf("OrderRepositoryMock.CreateOrderItems mock is already set by Set")
	}

	if mmCreateOrderItems.defaultExpectation == nil {
		mmCreateOrderItems.defaultExpectation = &OrderRepositoryMockCreateOrderItemsExpectation{}
	}

	if mmCreateOrderItems.defaultExpectation.params != nil {
		mmCreateOrderItems.mock.t.Fatalf("OrderRepositoryMock.CreateOrderItems mock is already set by Expect")
	}

	if mmCreateOrderItems.defaultExpectation.paramPtrs == nil {
		mmCreateOrderItems.defaultExpectation.paramPtrs = &OrderRepositoryMockCreateOrderItemsParamPtrs{}
	}
	mmCreateOrderItems.defaultExpectation.paramPtrs.items = &items
	mmCreateOrderItems.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmCreateOrderItems
}

// Inspect accepts an inspector function that has same arguments as the orderRepository.CreateOrderItems
func (mmCreateOrderItems *mOrderRepositoryMockCreateOrderItems) Inspect(f func(ctx context.Context, orderID int64, items []domain.Item)) *mOrderRepositoryMockCreateOrderItems {
	if mmCreateOrderItems.mock.inspectFuncCreateOrderItems != nil {
		mmCreateOrderItems.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.CreateOrderItems")
	}

	mmCreateOrderItems.mock.inspectFuncCreateOrderItems = f

	return mmCreateOrderItems
}

// Return sets up results that will be returned by orderRepository.CreateOrderItems
func (mmCreateOrderItems *mOrderRepositoryMockCreateOrderItems) Return(err error) *OrderRepositoryMock {
	if mmCreateOrderItems.mock.funcCreateOrderItems != nil {
		mmCreateOrderItems.mock.t.Fatalf("OrderRepositoryMock.CreateOrderItems mock is already set by Set")
	}

	if mmCreateOrderItems.defaultExpectation == nil {
		mmCreateOrderItems.defaultExpectation = &OrderRepositoryMockCreateOrderItemsExpectation{mock: mmCreateOrderItems.mock}
	}
	mmCreateOrderItems.defaultExpectation.results = &OrderRepositoryMockCreateOrderItemsResults{err}
	mmCreateOrderItems.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateOrderItems.mock
}

// Set uses given function f to mock the orderRepository.CreateOrderItems method
func (mmCreateOrderItems *mOrderRepositoryMockCreateOrderItems) Set(f func(ctx context.Context, orderID int64, items []domain.Item) (err error)) *OrderRepositoryMock {
	if mmCreateOrderItems.defaultExpectation != nil {
		mmCreateOrderItems.mock.t.Fatalf("Default expectation is already set for the orderRepository.CreateOrderItems method")
	}

	if len(mmCreateOrderItems.expectations) > 0 {
		mmCreateOrderItems.mock.t.Fatalf("Some expectations are already set for the orderRepository.CreateOrderItems method")
	}

	mmCreateOrderItems.mock.funcCreateOrderItems = f
	mmCreateOrderItems.mock.funcCreateOrderItemsOrigin = minimock.CallerInfo(1)
	return mmCreateOrderItems.mock
}

// When sets expectation for the orderRepository.CreateOrderItems which will trigger the result defined by the following
// Then helper
func (mmCreateOrderItems *mOrderRepositoryMockCreateOrderItems) When(ctx context.Context, orderID int64, items []domain.Item) *OrderRepositoryMockCreateOrderItemsExpectation {
	if mmCreateOrderItems.mock.funcCreateOrderItems != nil {
		mmCreateOrderItems.mock.t.Fatalf("OrderRepositoryMock.CreateOrderItems mock is already set by Set")
	}

	expectation := &OrderRepositoryMockCreateOrderItemsExpectation{
		mock:               mmCreateOrderItems.mock,
		params:             &OrderRepositoryMockCreateOrderItemsParams{ctx, orderID, items},
		expectationOrigins: OrderRepositoryMockCreateOrderItemsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateOrderItems.expectations = append(mmCreateOrderItems.expectations, expectation)
	return expectation
}

// Then sets up orderRepository.CreateOrderItems return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockCreateOrderItemsExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockCreateOrderItemsResults{err}
	return e.mock
}

// Times sets number of times orderRepository.CreateOrderItems should be invoked
func (mmCreateOrderItems *mOrderRepositoryMockCreateOrderItems) Times(n uint64) *mOrderRepositoryMockCreateOrderItems {
	if n == 0 {
		mmCreateOrderItems.mock.t.Fatalf("Times of OrderRepositoryMock.CreateOrderItems mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateOrderItems.expectedInvocations, n)
	mmCreateOrderItems.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateOrderItems
}

func (mmCreateOrderItems *mOrderRepositoryMockCreateOrderItems) invocationsDone() bool {
	if len(mmCreateOrderItems.expectations) == 0 && mmCreateOrderItems.defaultExpectation == nil && mmCreateOrderItems.mock.funcCreateOrderItems == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateOrderItems.mock.afterCreateOrderItemsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateOrderItems.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateOrderItems implements mm_order.orderRepository
func (mmCreateOrderItems *OrderRepositoryMock) CreateOrderItems(ctx context.Context, orderID int64, items []domain.Item) (err error) {
	mm_atomic.AddUint64(&mmCreateOrderItems.beforeCreateOrderItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrderItems.afterCreateOrderItemsCounter, 1)

	mmCreateOrderItems.t.Helper()

	if mmCreateOrderItems.inspectFuncCreateOrderItems != nil {
		mmCreateOrderItems.inspectFuncCreateOrderItems(ctx, orderID, items)
	}

	mm_params := OrderRepositoryMockCreateOrderItemsParams{ctx, orderID, items}

	// Record call args
	mmCreateOrderItems.CreateOrderItemsMock.mutex.Lock()
	mmCreateOrderItems.CreateOrderItemsMock.callArgs = append(mmCreateOrderItems.CreateOrderItemsMock.callArgs, &mm_params)
	mmCreateOrderItems.CreateOrderItemsMock.mutex.Unlock()

	for _, e := range mmCreateOrderItems.CreateOrderItemsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateOrderItems.CreateOrderItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrderItems.CreateOrderItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrderItems.CreateOrderItemsMock.defaultExpectation.params
		mm_want_ptrs := mmCreateOrderItems.CreateOrderItemsMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockCreateOrderItemsParams{ctx, orderID, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateOrderItems.t.Errorf("OrderRepositoryMock.CreateOrderItems got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrderItems.CreateOrderItemsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmCreateOrderItems.t.Errorf("OrderRepositoryMock.CreateOrderItems got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrderItems.CreateOrderItemsMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmCreateOrderItems.t.Errorf("OrderRepositoryMock.CreateOrderItems got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrderItems.CreateOrderItemsMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrderItems.t.Errorf("OrderRepositoryMock.CreateOrderItems got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateOrderItems.CreateOrderItemsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrderItems.CreateOrderItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrderItems.t.Fatal("No results are set for the OrderRepositoryMock.CreateOrderItems")
		}
		return (*mm_results).err
	}
	if mmCreateOrderItems.funcCreateOrderItems != nil {
		return mmCreateOrderItems.funcCreateOrderItems(ctx, orderID, items)
	}
	mmCreateOrderItems.t.Fatalf("Unexpected call to OrderRepositoryMock.CreateOrderItems. %v %v %v", ctx, orderID, items)
	return
}

// CreateOrderItemsAfterCounter returns a count of finished OrderRepositoryMock.CreateOrderItems invocations
func (mmCreateOrderItems *OrderRepositoryMock) CreateOrderItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrderItems.afterCreateOrderItemsCounter)
}

// CreateOrderItemsBeforeCounter returns a count of OrderRepositoryMock.CreateOrderItems invocations
func (mmCreateOrderItems *OrderRepositoryMock) CreateOrderItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrderItems.beforeCreateOrderItemsCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.CreateOrderItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrderItems *mOrderRepositoryMockCreateOrderItems) Calls() []*OrderRepositoryMockCreateOrderItemsParams {
	mmCreateOrderItems.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockCreateOrderItemsParams, len(mmCreateOrderItems.callArgs))
	copy(argCopy, mmCreateOrderItems.callArgs)

	mmCreateOrderItems.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderItemsDone returns true if the count of the CreateOrderItems invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockCreateOrderItemsDone() bool {
	if m.CreateOrderItemsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateOrderItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateOrderItemsMock.invocationsDone()
}

// MinimockCreateOrderItemsInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockCreateOrderItemsInspect() {
	for _, e := range m.CreateOrderItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.CreateOrderItems at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateOrderItemsCounter := mm_atomic.LoadUint64(&m.afterCreateOrderItemsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderItemsMock.defaultExpectation != nil && afterCreateOrderItemsCounter < 1 {
		if m.CreateOrderItemsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.CreateOrderItems at\n%s", m.CreateOrderItemsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.CreateOrderItems at\n%s with params: %#v", m.CreateOrderItemsMock.defaultExpectation.expectationOrigins.origin, *m.CreateOrderItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrderItems != nil && afterCreateOrderItemsCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.CreateOrderItems at\n%s", m.funcCreateOrderItemsOrigin)
	}

	if !m.CreateOrderItemsMock.invocationsDone() && afterCreateOrderItemsCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.CreateOrderItems at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateOrderItemsMock.expectedInvocations), m.CreateOrderItemsMock.expectedInvocationsOrigin, afterCreateOrderItemsCounter)
	}
}

type mOrderRepositoryMockGetByOrderID struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockGetByOrderIDExpectation
	expectations       []*OrderRepositoryMockGetByOrderIDExpectation

	callArgs []*OrderRepositoryMockGetByOrderIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockGetByOrderIDExpectation specifies expectation struct of the orderRepository.GetByOrderID
type OrderRepositoryMockGetByOrderIDExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockGetByOrderIDParams
	paramPtrs          *OrderRepositoryMockGetByOrderIDParamPtrs
	expectationOrigins OrderRepositoryMockGetByOrderIDExpectationOrigins
	results            *OrderRepositoryMockGetByOrderIDResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockGetByOrderIDParams contains parameters of the orderRepository.GetByOrderID
type OrderRepositoryMockGetByOrderIDParams struct {
	ctx     context.Context
	orderID int64
}

// OrderRepositoryMockGetByOrderIDParamPtrs contains pointers to parameters of the orderRepository.GetByOrderID
type OrderRepositoryMockGetByOrderIDParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// OrderRepositoryMockGetByOrderIDResults contains results of the orderRepository.GetByOrderID
type OrderRepositoryMockGetByOrderIDResults struct {
	o1  domain.Order
	err error
}

// OrderRepositoryMockGetByOrderIDOrigins contains origins of expectations of the orderRepository.GetByOrderID
type OrderRepositoryMockGetByOrderIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByOrderID *mOrderRepositoryMockGetByOrderID) Optional() *mOrderRepositoryMockGetByOrderID {
	mmGetByOrderID.optional = true
	return mmGetByOrderID
}

// Expect sets up expected params for orderRepository.GetByOrderID
func (mmGetByOrderID *mOrderRepositoryMockGetByOrderID) Expect(ctx context.Context, orderID int64) *mOrderRepositoryMockGetByOrderID {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetByOrderID mock is already set by Set")
	}

	if mmGetByOrderID.defaultExpectation == nil {
		mmGetByOrderID.defaultExpectation = &OrderRepositoryMockGetByOrderIDExpectation{}
	}

	if mmGetByOrderID.defaultExpectation.paramPtrs != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetByOrderID mock is already set by ExpectParams functions")
	}

	mmGetByOrderID.defaultExpectation.params = &OrderRepositoryMockGetByOrderIDParams{ctx, orderID}
	mmGetByOrderID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetByOrderID.expectations {
		if minimock.Equal(e.params, mmGetByOrderID.defaultExpectation.params) {
			mmGetByOrderID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByOrderID.defaultExpectation.params)
		}
	}

	return mmGetByOrderID
}

// ExpectCtxParam1 sets up expected param ctx for orderRepository.GetByOrderID
func (mmGetByOrderID *mOrderRepositoryMockGetByOrderID) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGetByOrderID {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetByOrderID mock is already set by Set")
	}

	if mmGetByOrderID.defaultExpectation == nil {
		mmGetByOrderID.defaultExpectation = &OrderRepositoryMockGetByOrderIDExpectation{}
	}

	if mmGetByOrderID.defaultExpectation.params != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetByOrderID mock is already set by Expect")
	}

	if mmGetByOrderID.defaultExpectation.paramPtrs == nil {
		mmGetByOrderID.defaultExpectation.paramPtrs = &OrderRepositoryMockGetByOrderIDParamPtrs{}
	}
	mmGetByOrderID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetByOrderID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetByOrderID
}

// ExpectOrderIDParam2 sets up expected param orderID for orderRepository.GetByOrderID
func (mmGetByOrderID *mOrderRepositoryMockGetByOrderID) ExpectOrderIDParam2(orderID int64) *mOrderRepositoryMockGetByOrderID {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetByOrderID mock is already set by Set")
	}

	if mmGetByOrderID.defaultExpectation == nil {
		mmGetByOrderID.defaultExpectation = &OrderRepositoryMockGetByOrderIDExpectation{}
	}

	if mmGetByOrderID.defaultExpectation.params != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetByOrderID mock is already set by Expect")
	}

	if mmGetByOrderID.defaultExpectation.paramPtrs == nil {
		mmGetByOrderID.defaultExpectation.paramPtrs = &OrderRepositoryMockGetByOrderIDParamPtrs{}
	}
	mmGetByOrderID.defaultExpectation.paramPtrs.orderID = &orderID
	mmGetByOrderID.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmGetByOrderID
}

// Inspect accepts an inspector function that has same arguments as the orderRepository.GetByOrderID
func (mmGetByOrderID *mOrderRepositoryMockGetByOrderID) Inspect(f func(ctx context.Context, orderID int64)) *mOrderRepositoryMockGetByOrderID {
	if mmGetByOrderID.mock.inspectFuncGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetByOrderID")
	}

	mmGetByOrderID.mock.inspectFuncGetByOrderID = f

	return mmGetByOrderID
}

// Return sets up results that will be returned by orderRepository.GetByOrderID
func (mmGetByOrderID *mOrderRepositoryMockGetByOrderID) Return(o1 domain.Order, err error) *OrderRepositoryMock {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetByOrderID mock is already set by Set")
	}

	if mmGetByOrderID.defaultExpectation == nil {
		mmGetByOrderID.defaultExpectation = &OrderRepositoryMockGetByOrderIDExpectation{mock: mmGetByOrderID.mock}
	}
	mmGetByOrderID.defaultExpectation.results = &OrderRepositoryMockGetByOrderIDResults{o1, err}
	mmGetByOrderID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetByOrderID.mock
}

// Set uses given function f to mock the orderRepository.GetByOrderID method
func (mmGetByOrderID *mOrderRepositoryMockGetByOrderID) Set(f func(ctx context.Context, orderID int64) (o1 domain.Order, err error)) *OrderRepositoryMock {
	if mmGetByOrderID.defaultExpectation != nil {
		mmGetByOrderID.mock.t.Fatalf("Default expectation is already set for the orderRepository.GetByOrderID method")
	}

	if len(mmGetByOrderID.expectations) > 0 {
		mmGetByOrderID.mock.t.Fatalf("Some expectations are already set for the orderRepository.GetByOrderID method")
	}

	mmGetByOrderID.mock.funcGetByOrderID = f
	mmGetByOrderID.mock.funcGetByOrderIDOrigin = minimock.CallerInfo(1)
	return mmGetByOrderID.mock
}

// When sets expectation for the orderRepository.GetByOrderID which will trigger the result defined by the following
// Then helper
func (mmGetByOrderID *mOrderRepositoryMockGetByOrderID) When(ctx context.Context, orderID int64) *OrderRepositoryMockGetByOrderIDExpectation {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetByOrderID mock is already set by Set")
	}

	expectation := &OrderRepositoryMockGetByOrderIDExpectation{
		mock:               mmGetByOrderID.mock,
		params:             &OrderRepositoryMockGetByOrderIDParams{ctx, orderID},
		expectationOrigins: OrderRepositoryMockGetByOrderIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetByOrderID.expectations = append(mmGetByOrderID.expectations, expectation)
	return expectation
}

// Then sets up orderRepository.GetByOrderID return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetByOrderIDExpectation) Then(o1 domain.Order, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockGetByOrderIDResults{o1, err}
	return e.mock
}

// Times sets number of times orderRepository.GetByOrderID should be invoked
func (mmGetByOrderID *mOrderRepositoryMockGetByOrderID) Times(n uint64) *mOrderRepositoryMockGetByOrderID {
	if n == 0 {
		mmGetByOrderID.mock.t.Fatalf("Times of OrderRepositoryMock.GetByOrderID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByOrderID.expectedInvocations, n)
	mmGetByOrderID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetByOrderID
}

func (mmGetByOrderID *mOrderRepositoryMockGetByOrderID) invocationsDone() bool {
	if len(mmGetByOrderID.expectations) == 0 && mmGetByOrderID.defaultExpectation == nil && mmGetByOrderID.mock.funcGetByOrderID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByOrderID.mock.afterGetByOrderIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByOrderID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByOrderID implements mm_order.orderRepository
func (mmGetByOrderID *OrderRepositoryMock) GetByOrderID(ctx context.Context, orderID int64) (o1 domain.Order, err error) {
	mm_atomic.AddUint64(&mmGetByOrderID.beforeGetByOrderIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByOrderID.afterGetByOrderIDCounter, 1)

	mmGetByOrderID.t.Helper()

	if mmGetByOrderID.inspectFuncGetByOrderID != nil {
		mmGetByOrderID.inspectFuncGetByOrderID(ctx, orderID)
	}

	mm_params := OrderRepositoryMockGetByOrderIDParams{ctx, orderID}

	// Record call args
	mmGetByOrderID.GetByOrderIDMock.mutex.Lock()
	mmGetByOrderID.GetByOrderIDMock.callArgs = append(mmGetByOrderID.GetByOrderIDMock.callArgs, &mm_params)
	mmGetByOrderID.GetByOrderIDMock.mutex.Unlock()

	for _, e := range mmGetByOrderID.GetByOrderIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmGetByOrderID.GetByOrderIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByOrderID.GetByOrderIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByOrderID.GetByOrderIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetByOrderID.GetByOrderIDMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockGetByOrderIDParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByOrderID.t.Errorf("OrderRepositoryMock.GetByOrderID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByOrderID.GetByOrderIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetByOrderID.t.Errorf("OrderRepositoryMock.GetByOrderID got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByOrderID.GetByOrderIDMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByOrderID.t.Errorf("OrderRepositoryMock.GetByOrderID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetByOrderID.GetByOrderIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByOrderID.GetByOrderIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByOrderID.t.Fatal("No results are set for the OrderRepositoryMock.GetByOrderID")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmGetByOrderID.funcGetByOrderID != nil {
		return mmGetByOrderID.funcGetByOrderID(ctx, orderID)
	}
	mmGetByOrderID.t.Fatalf("Unexpected call to OrderRepositoryMock.GetByOrderID. %v %v", ctx, orderID)
	return
}

// GetByOrderIDAfterCounter returns a count of finished OrderRepositoryMock.GetByOrderID invocations
func (mmGetByOrderID *OrderRepositoryMock) GetByOrderIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByOrderID.afterGetByOrderIDCounter)
}

// GetByOrderIDBeforeCounter returns a count of OrderRepositoryMock.GetByOrderID invocations
func (mmGetByOrderID *OrderRepositoryMock) GetByOrderIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByOrderID.beforeGetByOrderIDCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetByOrderID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByOrderID *mOrderRepositoryMockGetByOrderID) Calls() []*OrderRepositoryMockGetByOrderIDParams {
	mmGetByOrderID.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockGetByOrderIDParams, len(mmGetByOrderID.callArgs))
	copy(argCopy, mmGetByOrderID.callArgs)

	mmGetByOrderID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByOrderIDDone returns true if the count of the GetByOrderID invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetByOrderIDDone() bool {
	if m.GetByOrderIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByOrderIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByOrderIDMock.invocationsDone()
}

// MinimockGetByOrderIDInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetByOrderIDInspect() {
	for _, e := range m.GetByOrderIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetByOrderID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByOrderIDCounter := mm_atomic.LoadUint64(&m.afterGetByOrderIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByOrderIDMock.defaultExpectation != nil && afterGetByOrderIDCounter < 1 {
		if m.GetByOrderIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetByOrderID at\n%s", m.GetByOrderIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetByOrderID at\n%s with params: %#v", m.GetByOrderIDMock.defaultExpectation.expectationOrigins.origin, *m.GetByOrderIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByOrderID != nil && afterGetByOrderIDCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.GetByOrderID at\n%s", m.funcGetByOrderIDOrigin)
	}

	if !m.GetByOrderIDMock.invocationsDone() && afterGetByOrderIDCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.GetByOrderID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByOrderIDMock.expectedInvocations), m.GetByOrderIDMock.expectedInvocationsOrigin, afterGetByOrderIDCounter)
	}
}

type mOrderRepositoryMockGetByOrderIDForUpdate struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockGetByOrderIDForUpdateExpectation
	expectations       []*OrderRepositoryMockGetByOrderIDForUpdateExpectation

	callArgs []*OrderRepositoryMockGetByOrderIDForUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockGetByOrderIDForUpdateExpectation specifies expectation struct of the orderRepository.GetByOrderIDForUpdate
type OrderRepositoryMockGetByOrderIDForUpdateExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockGetByOrderIDForUpdateParams
	paramPtrs          *OrderRepositoryMockGetByOrderIDForUpdateParamPtrs
	expectationOrigins OrderRepositoryMockGetByOrderIDForUpdateExpectationOrigins
	results            *OrderRepositoryMockGetByOrderIDForUpdateResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockGetByOrderIDForUpdateParams contains parameters of the orderRepository.GetByOrderIDForUpdate
type OrderRepositoryMockGetByOrderIDForUpdateParams struct {
	ctx     context.Context
	orderID int64
}

// OrderRepositoryMockGetByOrderIDForUpdateParamPtrs contains pointers to parameters of the orderRepository.GetByOrderIDForUpdate
type OrderRepositoryMockGetByOrderIDForUpdateParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// OrderRepositoryMockGetByOrderIDForUpdateResults contains results of the orderRepository.GetByOrderIDForUpdate
type OrderRepositoryMockGetByOrderIDForUpdateResults struct {
	o1  domain.Order
	err error
}

// OrderRepositoryMockGetByOrderIDForUpdateOrigins contains origins of expectations of the orderRepository.GetByOrderIDForUpdate
type OrderRepositoryMockGetByOrderIDForUpdateExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByOrderIDForUpdate *mOrderRepositoryMockGetByOrderIDForUpdate) Optional() *mOrderRepositoryMockGetByOrderIDForUpdate {
	mmGetByOrderIDForUpdate.optional = true
	return mmGetByOrderIDForUpdate
}

// Expect sets up expected params for orderRepository.GetByOrderIDForUpdate
func (mmGetByOrderIDForUpdate *mOrderRepositoryMockGetByOrderIDForUpdate) Expect(ctx context.Context, orderID int64) *mOrderRepositoryMockGetByOrderIDForUpdate {
	if mmGetByOrderIDForUpdate.mock.funcGetByOrderIDForUpdate != nil {
		mmGetByOrderIDForUpdate.mock.t.Fatalf("OrderRepositoryMock.GetByOrderIDForUpdate mock is already set by Set")
	}

	if mmGetByOrderIDForUpdate.defaultExpectation == nil {
		mmGetByOrderIDForUpdate.defaultExpectation = &OrderRepositoryMockGetByOrderIDForUpdateExpectation{}
	}

	if mmGetByOrderIDForUpdate.defaultExpectation.paramPtrs != nil {
		mmGetByOrderIDForUpdate.mock.t.Fatalf("OrderRepositoryMock.GetByOrderIDForUpdate mock is already set by ExpectParams functions")
	}

	mmGetByOrderIDForUpdate.defaultExpectation.params = &OrderRepositoryMockGetByOrderIDForUpdateParams{ctx, orderID}
	mmGetByOrderIDForUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetByOrderIDForUpdate.expectations {
		if minimock.Equal(e.params, mmGetByOrderIDForUpdate.defaultExpectation.params) {
			mmGetByOrderIDForUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByOrderIDForUpdate.defaultExpectation.params)
		}
	}

	return mmGetByOrderIDForUpdate
}

// ExpectCtxParam1 sets up expected param ctx for orderRepository.GetByOrderIDForUpdate
func (mmGetByOrderIDForUpdate *mOrderRepositoryMockGetByOrderIDForUpdate) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGetByOrderIDForUpdate {
	if mmGetByOrderIDForUpdate.mock.funcGetByOrderIDForUpdate != nil {
		mmGetByOrderIDForUpdate.mock.t.Fatalf("OrderRepositoryMock.GetByOrderIDForUpdate mock is already set by Set")
	}

	if mmGetByOrderIDForUpdate.defaultExpectation == nil {
		mmGetByOrderIDForUpdate.defaultExpectation = &OrderRepositoryMockGetByOrderIDForUpdateExpectation{}
	}

	if mmGetByOrderIDForUpdate.defaultExpectation.params != nil {
		mmGetByOrderIDForUpdate.mock.t.Fatalf("OrderRepositoryMock.GetByOrderIDForUpdate mock is already set by Expect")
	}

	if mmGetByOrderIDForUpdate.defaultExpectation.paramPtrs == nil {
		mmGetByOrderIDForUpdate.defaultExpectation.paramPtrs = &OrderRepositoryMockGetByOrderIDForUpdateParamPtrs{}
	}
	mmGetByOrderIDForUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetByOrderIDForUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetByOrderIDForUpdate
}

// ExpectOrderIDParam2 sets up expected param orderID for orderRepository.GetByOrderIDForUpdate
func (mmGetByOrderIDForUpdate *mOrderRepositoryMockGetByOrderIDForUpdate) ExpectOrderIDParam2(orderID int64) *mOrderRepositoryMockGetByOrderIDForUpdate {
	if mmGetByOrderIDForUpdate.mock.funcGetByOrderIDForUpdate != nil {
		mmGetByOrderIDForUpdate.mock.t.Fatalf("OrderRepositoryMock.GetByOrderIDForUpdate mock is already set by Set")
	}

	if mmGetByOrderIDForUpdate.defaultExpectation == nil {
		mmGetByOrderIDForUpdate.defaultExpectation = &OrderRepositoryMockGetByOrderIDForUpdateExpectation{}
	}

	if mmGetByOrderIDForUpdate.defaultExpectation.params != nil {
		mmGetByOrderIDForUpdate.mock.t.Fatalf("OrderRepositoryMock.GetByOrderIDForUpdate mock is already set by Expect")
	}

	if mmGetByOrderIDForUpdate.defaultExpectation.paramPtrs == nil {
		mmGetByOrderIDForUpdate.defaultExpectation.paramPtrs = &OrderRepositoryMockGetByOrderIDForUpdateParamPtrs{}
	}
	mmGetByOrderIDForUpdate.defaultExpectation.paramPtrs.orderID = &orderID
	mmGetByOrderIDForUpdate.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmGetByOrderIDForUpdate
}

// Inspect accepts an inspector function that has same arguments as the orderRepository.GetByOrderIDForUpdate
func (mmGetByOrderIDForUpdate *mOrderRepositoryMockGetByOrderIDForUpdate) Inspect(f func(ctx context.Context, orderID int64)) *mOrderRepositoryMockGetByOrderIDForUpdate {
	if mmGetByOrderIDForUpdate.mock.inspectFuncGetByOrderIDForUpdate != nil {
		mmGetByOrderIDForUpdate.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetByOrderIDForUpdate")
	}

	mmGetByOrderIDForUpdate.mock.inspectFuncGetByOrderIDForUpdate = f

	return mmGetByOrderIDForUpdate
}

// Return sets up results that will be returned by orderRepository.GetByOrderIDForUpdate
func (mmGetByOrderIDForUpdate *mOrderRepositoryMockGetByOrderIDForUpdate) Return(o1 domain.Order, err error) *OrderRepositoryMock {
	if mmGetByOrderIDForUpdate.mock.funcGetByOrderIDForUpdate != nil {
		mmGetByOrderIDForUpdate.mock.t.Fatalf("OrderRepositoryMock.GetByOrderIDForUpdate mock is already set by Set")
	}

	if mmGetByOrderIDForUpdate.defaultExpectation == nil {
		mmGetByOrderIDForUpdate.defaultExpectation = &OrderRepositoryMockGetByOrderIDForUpdateExpectation{mock: mmGetByOrderIDForUpdate.mock}
	}
	mmGetByOrderIDForUpdate.defaultExpectation.results = &OrderRepositoryMockGetByOrderIDForUpdateResults{o1, err}
	mmGetByOrderIDForUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetByOrderIDForUpdate.mock
}

// Set uses given function f to mock the orderRepository.GetByOrderIDForUpdate method
func (mmGetByOrderIDForUpdate *mOrderRepositoryMockGetByOrderIDForUpdate) Set(f func(ctx context.Context, orderID int64) (o1 domain.Order, err error)) *OrderRepositoryMock {
	if mmGetByOrderIDForUpdate.defaultExpectation != nil {
		mmGetByOrderIDForUpdate.mock.t.Fatalf("Default expectation is already set for the orderRepository.GetByOrderIDForUpdate method")
	}

	if len(mmGetByOrderIDForUpdate.expectations) > 0 {
		mmGetByOrderIDForUpdate.mock.t.Fatalf("Some expectations are already set for the orderRepository.GetByOrderIDForUpdate method")
	}

	mmGetByOrderIDForUpdate.mock.funcGetByOrderIDForUpdate = f
	mmGetByOrderIDForUpdate.mock.funcGetByOrderIDForUpdateOrigin = minimock.CallerInfo(1)
	return mmGetByOrderIDForUpdate.mock
}

// When sets expectation for the orderRepository.GetByOrderIDForUpdate which will trigger the result defined by the following
// Then helper
func (mmGetByOrderIDForUpdate *mOrderRepositoryMockGetByOrderIDForUpdate) When(ctx context.Context, orderID int64) *OrderRepositoryMockGetByOrderIDForUpdateExpectation {
	if mmGetByOrderIDForUpdate.mock.funcGetByOrderIDForUpdate != nil {
		mmGetByOrderIDForUpdate.mock.t.Fatalf("OrderRepositoryMock.GetByOrderIDForUpdate mock is already set by Set")
	}

	expectation := &OrderRepositoryMockGetByOrderIDForUpdateExpectation{
		mock:               mmGetByOrderIDForUpdate.mock,
		params:             &OrderRepositoryMockGetByOrderIDForUpdateParams{ctx, orderID},
		expectationOrigins: OrderRepositoryMockGetByOrderIDForUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetByOrderIDForUpdate.expectations = append(mmGetByOrderIDForUpdate.expectations, expectation)
	return expectation
}

// Then sets up orderRepository.GetByOrderIDForUpdate return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetByOrderIDForUpdateExpectation) Then(o1 domain.Order, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockGetByOrderIDForUpdateResults{o1, err}
	return e.mock
}

// Times sets number of times orderRepository.GetByOrderIDForUpdate should be invoked
func (mmGetByOrderIDForUpdate *mOrderRepositoryMockGetByOrderIDForUpdate) Times(n uint64) *mOrderRepositoryMockGetByOrderIDForUpdate {
	if n == 0 {
		mmGetByOrderIDForUpdate.mock.t.Fatalf("Times of OrderRepositoryMock.GetByOrderIDForUpdate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByOrderIDForUpdate.expectedInvocations, n)
	mmGetByOrderIDForUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetByOrderIDForUpdate
}

func (mmGetByOrderIDForUpdate *mOrderRepositoryMockGetByOrderIDForUpdate) invocationsDone() bool {
	if len(mmGetByOrderIDForUpdate.expectations) == 0 && mmGetByOrderIDForUpdate.defaultExpectation == nil && mmGetByOrderIDForUpdate.mock.funcGetByOrderIDForUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByOrderIDForUpdate.mock.afterGetByOrderIDForUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByOrderIDForUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByOrderIDForUpdate implements mm_order.orderRepository
func (mmGetByOrderIDForUpdate *OrderRepositoryMock) GetByOrderIDForUpdate(ctx context.Context, orderID int64) (o1 domain.Order, err error) {
	mm_atomic.AddUint64(&mmGetByOrderIDForUpdate.beforeGetByOrderIDForUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByOrderIDForUpdate.afterGetByOrderIDForUpdateCounter, 1)

	mmGetByOrderIDForUpdate.t.Helper()

	if mmGetByOrderIDForUpdate.inspectFuncGetByOrderIDForUpdate != nil {
		mmGetByOrderIDForUpdate.inspectFuncGetByOrderIDForUpdate(ctx, orderID)
	}

	mm_params := OrderRepositoryMockGetByOrderIDForUpdateParams{ctx, orderID}

	// Record call args
	mmGetByOrderIDForUpdate.GetByOrderIDForUpdateMock.mutex.Lock()
	mmGetByOrderIDForUpdate.GetByOrderIDForUpdateMock.callArgs = append(mmGetByOrderIDForUpdate.GetByOrderIDForUpdateMock.callArgs, &mm_params)
	mmGetByOrderIDForUpdate.GetByOrderIDForUpdateMock.mutex.Unlock()

	for _, e := range mmGetByOrderIDForUpdate.GetByOrderIDForUpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmGetByOrderIDForUpdate.GetByOrderIDForUpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByOrderIDForUpdate.GetByOrderIDForUpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByOrderIDForUpdate.GetByOrderIDForUpdateMock.defaultExpectation.params
		mm_want_ptrs := mmGetByOrderIDForUpdate.GetByOrderIDForUpdateMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockGetByOrderIDForUpdateParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByOrderIDForUpdate.t.Errorf("OrderRepositoryMock.GetByOrderIDForUpdate got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByOrderIDForUpdate.GetByOrderIDForUpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetByOrderIDForUpdate.t.Errorf("OrderRepositoryMock.GetByOrderIDForUpdate got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByOrderIDForUpdate.GetByOrderIDForUpdateMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByOrderIDForUpdate.t.Errorf("OrderRepositoryMock.GetByOrderIDForUpdate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetByOrderIDForUpdate.GetByOrderIDForUpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByOrderIDForUpdate.GetByOrderIDForUpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByOrderIDForUpdate.t.Fatal("No results are set for the OrderRepositoryMock.GetByOrderIDForUpdate")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmGetByOrderIDForUpdate.funcGetByOrderIDForUpdate != nil {
		return mmGetByOrderIDForUpdate.funcGetByOrderIDForUpdate(ctx, orderID)
	}
	mmGetByOrderIDForUpdate.t.Fatalf("Unexpected call to OrderRepositoryMock.GetByOrderIDForUpdate. %v %v", ctx, orderID)
	return
}

// GetByOrderIDForUpdateAfterCounter returns a count of finished OrderRepositoryMock.GetByOrderIDForUpdate invocations
func (mmGetByOrderIDForUpdate *OrderRepositoryMock) GetByOrderIDForUpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByOrderIDForUpdate.afterGetByOrderIDForUpdateCounter)
}

// GetByOrderIDForUpdateBeforeCounter returns a count of OrderRepositoryMock.GetByOrderIDForUpdate invocations
func (mmGetByOrderIDForUpdate *OrderRepositoryMock) GetByOrderIDForUpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByOrderIDForUpdate.beforeGetByOrderIDForUpdateCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetByOrderIDForUpdate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByOrderIDForUpdate *mOrderRepositoryMockGetByOrderIDForUpdate) Calls() []*OrderRepositoryMockGetByOrderIDForUpdateParams {
	mmGetByOrderIDForUpdate.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockGetByOrderIDForUpdateParams, len(mmGetByOrderIDForUpdate.callArgs))
	copy(argCopy, mmGetByOrderIDForUpdate.callArgs)

	mmGetByOrderIDForUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockGetByOrderIDForUpdateDone returns true if the count of the GetByOrderIDForUpdate invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetByOrderIDForUpdateDone() bool {
	if m.GetByOrderIDForUpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByOrderIDForUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByOrderIDForUpdateMock.invocationsDone()
}

// MinimockGetByOrderIDForUpdateInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetByOrderIDForUpdateInspect() {
	for _, e := range m.GetByOrderIDForUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetByOrderIDForUpdate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByOrderIDForUpdateCounter := mm_atomic.LoadUint64(&m.afterGetByOrderIDForUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByOrderIDForUpdateMock.defaultExpectation != nil && afterGetByOrderIDForUpdateCounter < 1 {
		if m.GetByOrderIDForUpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetByOrderIDForUpdate at\n%s", m.GetByOrderIDForUpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetByOrderIDForUpdate at\n%s with params: %#v", m.GetByOrderIDForUpdateMock.defaultExpectation.expectationOrigins.origin, *m.GetByOrderIDForUpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByOrderIDForUpdate != nil && afterGetByOrderIDForUpdateCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.GetByOrderIDForUpdate at\n%s", m.funcGetByOrderIDForUpdateOrigin)
	}

	if !m.GetByOrderIDForUpdateMock.invocationsDone() && afterGetByOrderIDForUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.GetByOrderIDForUpdate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByOrderIDForUpdateMock.expectedInvocations), m.GetByOrderIDForUpdateMock.expectedInvocationsOrigin, afterGetByOrderIDForUpdateCounter)
	}
}

type mOrderRepositoryMockSetStatus struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockSetStatusExpectation
	expectations       []*OrderRepositoryMockSetStatusExpectation

	callArgs []*OrderRepositoryMockSetStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockSetStatusExpectation specifies expectation struct of the orderRepository.SetStatus
type OrderRepositoryMockSetStatusExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockSetStatusParams
	paramPtrs          *OrderRepositoryMockSetStatusParamPtrs
	expectationOrigins OrderRepositoryMockSetStatusExpectationOrigins
	results            *OrderRepositoryMockSetStatusResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockSetStatusParams contains parameters of the orderRepository.SetStatus
type OrderRepositoryMockSetStatusParams struct {
	ctx     context.Context
	orderID int64
	status  domain.OrderStatus
}

// OrderRepositoryMockSetStatusParamPtrs contains pointers to parameters of the orderRepository.SetStatus
type OrderRepositoryMockSetStatusParamPtrs struct {
	ctx     *context.Context
	orderID *int64
	status  *domain.OrderStatus
}

// OrderRepositoryMockSetStatusResults contains results of the orderRepository.SetStatus
type OrderRepositoryMockSetStatusResults struct {
	err error
}

// OrderRepositoryMockSetStatusOrigins contains origins of expectations of the orderRepository.SetStatus
type OrderRepositoryMockSetStatusExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
	originStatus  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetStatus *mOrderRepositoryMockSetStatus) Optional() *mOrderRepositoryMockSetStatus {
	mmSetStatus.optional = true
	return mmSetStatus
}

// Expect sets up expected params for orderRepository.SetStatus
func (mmSetStatus *mOrderRepositoryMockSetStatus) Expect(ctx context.Context, orderID int64, status domain.OrderStatus) *mOrderRepositoryMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepositoryMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.paramPtrs != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by ExpectParams functions")
	}

	mmSetStatus.defaultExpectation.params = &OrderRepositoryMockSetStatusParams{ctx, orderID, status}
	mmSetStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetStatus.expectations {
		if minimock.Equal(e.params, mmSetStatus.defaultExpectation.params) {
			mmSetStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatus.defaultExpectation.params)
		}
	}

	return mmSetStatus
}

// ExpectCtxParam1 sets up expected param ctx for orderRepository.SetStatus
func (mmSetStatus *mOrderRepositoryMockSetStatus) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepositoryMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderRepositoryMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetStatus.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetStatus
}

// ExpectOrderIDParam2 sets up expected param orderID for orderRepository.SetStatus
func (mmSetStatus *mOrderRepositoryMockSetStatus) ExpectOrderIDParam2(orderID int64) *mOrderRepositoryMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepositoryMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderRepositoryMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.orderID = &orderID
	mmSetStatus.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmSetStatus
}

// ExpectStatusParam3 sets up expected param status for orderRepository.SetStatus
func (mmSetStatus *mOrderRepositoryMockSetStatus) ExpectStatusParam3(status domain.OrderStatus) *mOrderRepositoryMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepositoryMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderRepositoryMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.status = &status
	mmSetStatus.defaultExpectation.expectationOrigins.originStatus = minimock.CallerInfo(1)

	return mmSetStatus
}

// Inspect accepts an inspector function that has same arguments as the orderRepository.SetStatus
func (mmSetStatus *mOrderRepositoryMockSetStatus) Inspect(f func(ctx context.Context, orderID int64, status domain.OrderStatus)) *mOrderRepositoryMockSetStatus {
	if mmSetStatus.mock.inspectFuncSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.SetStatus")
	}

	mmSetStatus.mock.inspectFuncSetStatus = f

	return mmSetStatus
}

// Return sets up results that will be returned by orderRepository.SetStatus
func (mmSetStatus *mOrderRepositoryMockSetStatus) Return(err error) *OrderRepositoryMock {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepositoryMockSetStatusExpectation{mock: mmSetStatus.mock}
	}
	mmSetStatus.defaultExpectation.results = &OrderRepositoryMockSetStatusResults{err}
	mmSetStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetStatus.mock
}

// Set uses given function f to mock the orderRepository.SetStatus method
func (mmSetStatus *mOrderRepositoryMockSetStatus) Set(f func(ctx context.Context, orderID int64, status domain.OrderStatus) (err error)) *OrderRepositoryMock {
	if mmSetStatus.defaultExpectation != nil {
		mmSetStatus.mock.t.Fatalf("Default expectation is already set for the orderRepository.SetStatus method")
	}

	if len(mmSetStatus.expectations) > 0 {
		mmSetStatus.mock.t.Fatalf("Some expectations are already set for the orderRepository.SetStatus method")
	}

	mmSetStatus.mock.funcSetStatus = f
	mmSetStatus.mock.funcSetStatusOrigin = minimock.CallerInfo(1)
	return mmSetStatus.mock
}

// When sets expectation for the orderRepository.SetStatus which will trigger the result defined by the following
// Then helper
func (mmSetStatus *mOrderRepositoryMockSetStatus) When(ctx context.Context, orderID int64, status domain.OrderStatus) *OrderRepositoryMockSetStatusExpectation {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by Set")
	}

	expectation := &OrderRepositoryMockSetStatusExpectation{
		mock:               mmSetStatus.mock,
		params:             &OrderRepositoryMockSetStatusParams{ctx, orderID, status},
		expectationOrigins: OrderRepositoryMockSetStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetStatus.expectations = append(mmSetStatus.expectations, expectation)
	return expectation
}

// Then sets up orderRepository.SetStatus return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockSetStatusExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockSetStatusResults{err}
	return e.mock
}

// Times sets number of times orderRepository.SetStatus should be invoked
func (mmSetStatus *mOrderRepositoryMockSetStatus) Times(n uint64) *mOrderRepositoryMockSetStatus {
	if n == 0 {
		mmSetStatus.mock.t.Fatalf("Times of OrderRepositoryMock.SetStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetStatus.expectedInvocations, n)
	mmSetStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetStatus
}

func (mmSetStatus *mOrderRepositoryMockSetStatus) invocationsDone() bool {
	if len(mmSetStatus.expectations) == 0 && mmSetStatus.defaultExpectation == nil && mmSetStatus.mock.funcSetStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetStatus.mock.afterSetStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetStatus implements mm_order.orderRepository
func (mmSetStatus *OrderRepositoryMock) SetStatus(ctx context.Context, orderID int64, status domain.OrderStatus) (err error) {
	mm_atomic.AddUint64(&mmSetStatus.beforeSetStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatus.afterSetStatusCounter, 1)

	mmSetStatus.t.Helper()

	if mmSetStatus.inspectFuncSetStatus != nil {
		mmSetStatus.inspectFuncSetStatus(ctx, orderID, status)
	}

	mm_params := OrderRepositoryMockSetStatusParams{ctx, orderID, status}

	// Record call args
	mmSetStatus.SetStatusMock.mutex.Lock()
	mmSetStatus.SetStatusMock.callArgs = append(mmSetStatus.SetStatusMock.callArgs, &mm_params)
	mmSetStatus.SetStatusMock.mutex.Unlock()

	for _, e := range mmSetStatus.SetStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStatus.SetStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatus.SetStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatus.SetStatusMock.defaultExpectation.params
		mm_want_ptrs := mmSetStatus.SetStatusMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockSetStatusParams{ctx, orderID, status}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetStatus.t.Errorf("OrderRepositoryMock.SetStatus got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmSetStatus.t.Errorf("OrderRepositoryMock.SetStatus got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmSetStatus.t.Errorf("OrderRepositoryMock.SetStatus got unexpected parameter status, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.originStatus, *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatus.t.Errorf("OrderRepositoryMock.SetStatus got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStatus.SetStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStatus.t.Fatal("No results are set for the OrderRepositoryMock.SetStatus")
		}
		return (*mm_results).err
	}
	if mmSetStatus.funcSetStatus != nil {
		return mmSetStatus.funcSetStatus(ctx, orderID, status)
	}
	mmSetStatus.t.Fatalf("Unexpected call to OrderRepositoryMock.SetStatus. %v %v %v", ctx, orderID, status)
	return
}

// SetStatusAfterCounter returns a count of finished OrderRepositoryMock.SetStatus invocations
func (mmSetStatus *OrderRepositoryMock) SetStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.afterSetStatusCounter)
}

// SetStatusBeforeCounter returns a count of OrderRepositoryMock.SetStatus invocations
func (mmSetStatus *OrderRepositoryMock) SetStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.beforeSetStatusCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.SetStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatus *mOrderRepositoryMockSetStatus) Calls() []*OrderRepositoryMockSetStatusParams {
	mmSetStatus.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockSetStatusParams, len(mmSetStatus.callArgs))
	copy(argCopy, mmSetStatus.callArgs)

	mmSetStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusDone returns true if the count of the SetStatus invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockSetStatusDone() bool {
	if m.SetStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStatusMock.invocationsDone()
}

// MinimockSetStatusInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockSetStatusInspect() {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.SetStatus at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetStatusCounter := mm_atomic.LoadUint64(&m.afterSetStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && afterSetStatusCounter < 1 {
		if m.SetStatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.SetStatus at\n%s", m.SetStatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.SetStatus at\n%s with params: %#v", m.SetStatusMock.defaultExpectation.expectationOrigins.origin, *m.SetStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && afterSetStatusCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.SetStatus at\n%s", m.funcSetStatusOrigin)
	}

	if !m.SetStatusMock.invocationsDone() && afterSetStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.SetStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetStatusMock.expectedInvocations), m.SetStatusMock.expectedInvocationsOrigin, afterSetStatusCounter)
	}
}

type mOrderRepositoryMockSetStatusAndCreateEvent struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockSetStatusAndCreateEventExpectation
	expectations       []*OrderRepositoryMockSetStatusAndCreateEventExpectation

	callArgs []*OrderRepositoryMockSetStatusAndCreateEventParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockSetStatusAndCreateEventExpectation specifies expectation struct of the orderRepository.SetStatusAndCreateEvent
type OrderRepositoryMockSetStatusAndCreateEventExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockSetStatusAndCreateEventParams
	paramPtrs          *OrderRepositoryMockSetStatusAndCreateEventParamPtrs
	expectationOrigins OrderRepositoryMockSetStatusAndCreateEventExpectationOrigins
	results            *OrderRepositoryMockSetStatusAndCreateEventResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockSetStatusAndCreateEventParams contains parameters of the orderRepository.SetStatusAndCreateEvent
type OrderRepositoryMockSetStatusAndCreateEventParams struct {
	ctx     context.Context
	orderID int64
	status  domain.OrderStatus
	event   domain.Event
}

// OrderRepositoryMockSetStatusAndCreateEventParamPtrs contains pointers to parameters of the orderRepository.SetStatusAndCreateEvent
type OrderRepositoryMockSetStatusAndCreateEventParamPtrs struct {
	ctx     *context.Context
	orderID *int64
	status  *domain.OrderStatus
	event   *domain.Event
}

// OrderRepositoryMockSetStatusAndCreateEventResults contains results of the orderRepository.SetStatusAndCreateEvent
type OrderRepositoryMockSetStatusAndCreateEventResults struct {
	err error
}

// OrderRepositoryMockSetStatusAndCreateEventOrigins contains origins of expectations of the orderRepository.SetStatusAndCreateEvent
type OrderRepositoryMockSetStatusAndCreateEventExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
	originStatus  string
	originEvent   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetStatusAndCreateEvent *mOrderRepositoryMockSetStatusAndCreateEvent) Optional() *mOrderRepositoryMockSetStatusAndCreateEvent {
	mmSetStatusAndCreateEvent.optional = true
	return mmSetStatusAndCreateEvent
}

// Expect sets up expected params for orderRepository.SetStatusAndCreateEvent
func (mmSetStatusAndCreateEvent *mOrderRepositoryMockSetStatusAndCreateEvent) Expect(ctx context.Context, orderID int64, status domain.OrderStatus, event domain.Event) *mOrderRepositoryMockSetStatusAndCreateEvent {
	if mmSetStatusAndCreateEvent.mock.funcSetStatusAndCreateEvent != nil {
		mmSetStatusAndCreateEvent.mock.t.Fatalf("OrderRepositoryMock.SetStatusAndCreateEvent mock is already set by Set")
	}

	if mmSetStatusAndCreateEvent.defaultExpectation == nil {
		mmSetStatusAndCreateEvent.defaultExpectation = &OrderRepositoryMockSetStatusAndCreateEventExpectation{}
	}

	if mmSetStatusAndCreateEvent.defaultExpectation.paramPtrs != nil {
		mmSetStatusAndCreateEvent.mock.t.Fatalf("OrderRepositoryMock.SetStatusAndCreateEvent mock is already set by ExpectParams functions")
	}

	mmSetStatusAndCreateEvent.defaultExpectation.params = &OrderRepositoryMockSetStatusAndCreateEventParams{ctx, orderID, status, event}
	mmSetStatusAndCreateEvent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetStatusAndCreateEvent.expectations {
		if minimock.Equal(e.params, mmSetStatusAndCreateEvent.defaultExpectation.params) {
			mmSetStatusAndCreateEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatusAndCreateEvent.defaultExpectation.params)
		}
	}

	return mmSetStatusAndCreateEvent
}

// ExpectCtxParam1 sets up expected param ctx for orderRepository.SetStatusAndCreateEvent
func (mmSetStatusAndCreateEvent *mOrderRepositoryMockSetStatusAndCreateEvent) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockSetStatusAndCreateEvent {
	if mmSetStatusAndCreateEvent.mock.funcSetStatusAndCreateEvent != nil {
		mmSetStatusAndCreateEvent.mock.t.Fatalf("OrderRepositoryMock.SetStatusAndCreateEvent mock is already set by Set")
	}

	if mmSetStatusAndCreateEvent.defaultExpectation == nil {
		mmSetStatusAndCreateEvent.defaultExpectation = &OrderRepositoryMockSetStatusAndCreateEventExpectation{}
	}

	if mmSetStatusAndCreateEvent.defaultExpectation.params != nil {
		mmSetStatusAndCreateEvent.mock.t.Fatalf("OrderRepositoryMock.SetStatusAndCreateEvent mock is already set by Expect")
	}

	if mmSetStatusAndCreateEvent.defaultExpectation.paramPtrs == nil {
		mmSetStatusAndCreateEvent.defaultExpectation.paramPtrs = &OrderRepositoryMockSetStatusAndCreateEventParamPtrs{}
	}
	mmSetStatusAndCreateEvent.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetStatusAndCreateEvent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetStatusAndCreateEvent
}

// ExpectOrderIDParam2 sets up expected param orderID for orderRepository.SetStatusAndCreateEvent
func (mmSetStatusAndCreateEvent *mOrderRepositoryMockSetStatusAndCreateEvent) ExpectOrderIDParam2(orderID int64) *mOrderRepositoryMockSetStatusAndCreateEvent {
	if mmSetStatusAndCreateEvent.mock.funcSetStatusAndCreateEvent != nil {
		mmSetStatusAndCreateEvent.mock.t.Fatalf("OrderRepositoryMock.SetStatusAndCreateEvent mock is already set by Set")
	}

	if mmSetStatusAndCreateEvent.defaultExpectation == nil {
		mmSetStatusAndCreateEvent.defaultExpectation = &OrderRepositoryMockSetStatusAndCreateEventExpectation{}
	}

	if mmSetStatusAndCreateEvent.defaultExpectation.params != nil {
		mmSetStatusAndCreateEvent.mock.t.Fatalf("OrderRepositoryMock.SetStatusAndCreateEvent mock is already set by Expect")
	}

	if mmSetStatusAndCreateEvent.defaultExpectation.paramPtrs == nil {
		mmSetStatusAndCreateEvent.defaultExpectation.paramPtrs = &OrderRepositoryMockSetStatusAndCreateEventParamPtrs{}
	}
	mmSetStatusAndCreateEvent.defaultExpectation.paramPtrs.orderID = &orderID
	mmSetStatusAndCreateEvent.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmSetStatusAndCreateEvent
}

// ExpectStatusParam3 sets up expected param status for orderRepository.SetStatusAndCreateEvent
func (mmSetStatusAndCreateEvent *mOrderRepositoryMockSetStatusAndCreateEvent) ExpectStatusParam3(status domain.OrderStatus) *mOrderRepositoryMockSetStatusAndCreateEvent {
	if mmSetStatusAndCreateEvent.mock.funcSetStatusAndCreateEvent != nil {
		mmSetStatusAndCreateEvent.mock.t.Fatalf("OrderRepositoryMock.SetStatusAndCreateEvent mock is already set by Set")
	}

	if mmSetStatusAndCreateEvent.defaultExpectation == nil {
		mmSetStatusAndCreateEvent.defaultExpectation = &OrderRepositoryMockSetStatusAndCreateEventExpectation{}
	}

	if mmSetStatusAndCreateEvent.defaultExpectation.params != nil {
		mmSetStatusAndCreateEvent.mock.t.Fatalf("OrderRepositoryMock.SetStatusAndCreateEvent mock is already set by Expect")
	}

	if mmSetStatusAndCreateEvent.defaultExpectation.paramPtrs == nil {
		mmSetStatusAndCreateEvent.defaultExpectation.paramPtrs = &OrderRepositoryMockSetStatusAndCreateEventParamPtrs{}
	}
	mmSetStatusAndCreateEvent.defaultExpectation.paramPtrs.status = &status
	mmSetStatusAndCreateEvent.defaultExpectation.expectationOrigins.originStatus = minimock.CallerInfo(1)

	return mmSetStatusAndCreateEvent
}

// ExpectEventParam4 sets up expected param event for orderRepository.SetStatusAndCreateEvent
func (mmSetStatusAndCreateEvent *mOrderRepositoryMockSetStatusAndCreateEvent) ExpectEventParam4(event domain.Event) *mOrderRepositoryMockSetStatusAndCreateEvent {
	if mmSetStatusAndCreateEvent.mock.funcSetStatusAndCreateEvent != nil {
		mmSetStatusAndCreateEvent.mock.t.Fatalf("OrderRepositoryMock.SetStatusAndCreateEvent mock is already set by Set")
	}

	if mmSetStatusAndCreateEvent.defaultExpectation == nil {
		mmSetStatusAndCreateEvent.defaultExpectation = &OrderRepositoryMockSetStatusAndCreateEventExpectation{}
	}

	if mmSetStatusAndCreateEvent.defaultExpectation.params != nil {
		mmSetStatusAndCreateEvent.mock.t.Fatalf("OrderRepositoryMock.SetStatusAndCreateEvent mock is already set by Expect")
	}

	if mmSetStatusAndCreateEvent.defaultExpectation.paramPtrs == nil {
		mmSetStatusAndCreateEvent.defaultExpectation.paramPtrs = &OrderRepositoryMockSetStatusAndCreateEventParamPtrs{}
	}
	mmSetStatusAndCreateEvent.defaultExpectation.paramPtrs.event = &event
	mmSetStatusAndCreateEvent.defaultExpectation.expectationOrigins.originEvent = minimock.CallerInfo(1)

	return mmSetStatusAndCreateEvent
}

// Inspect accepts an inspector function that has same arguments as the orderRepository.SetStatusAndCreateEvent
func (mmSetStatusAndCreateEvent *mOrderRepositoryMockSetStatusAndCreateEvent) Inspect(f func(ctx context.Context, orderID int64, status domain.OrderStatus, event domain.Event)) *mOrderRepositoryMockSetStatusAndCreateEvent {
	if mmSetStatusAndCreateEvent.mock.inspectFuncSetStatusAndCreateEvent != nil {
		mmSetStatusAndCreateEvent.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.SetStatusAndCreateEvent")
	}

	mmSetStatusAndCreateEvent.mock.inspectFuncSetStatusAndCreateEvent = f

	return mmSetStatusAndCreateEvent
}

// Return sets up results that will be returned by orderRepository.SetStatusAndCreateEvent
func (mmSetStatusAndCreateEvent *mOrderRepositoryMockSetStatusAndCreateEvent) Return(err error) *OrderRepositoryMock {
	if mmSetStatusAndCreateEvent.mock.funcSetStatusAndCreateEvent != nil {
		mmSetStatusAndCreateEvent.mock.t.Fatalf("OrderRepositoryMock.SetStatusAndCreateEvent mock is already set by Set")
	}

	if mmSetStatusAndCreateEvent.defaultExpectation == nil {
		mmSetStatusAndCreateEvent.defaultExpectation = &OrderRepositoryMockSetStatusAndCreateEventExpectation{mock: mmSetStatusAndCreateEvent.mock}
	}
	mmSetStatusAndCreateEvent.defaultExpectation.results = &OrderRepositoryMockSetStatusAndCreateEventResults{err}
	mmSetStatusAndCreateEvent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetStatusAndCreateEvent.mock
}

// Set uses given function f to mock the orderRepository.SetStatusAndCreateEvent method
func (mmSetStatusAndCreateEvent *mOrderRepositoryMockSetStatusAndCreateEvent) Set(f func(ctx context.Context, orderID int64, status domain.OrderStatus, event domain.Event) (err error)) *OrderRepositoryMock {
	if mmSetStatusAndCreateEvent.defaultExpectation != nil {
		mmSetStatusAndCreateEvent.mock.t.Fatalf("Default expectation is already set for the orderRepository.SetStatusAndCreateEvent method")
	}

	if len(mmSetStatusAndCreateEvent.expectations) > 0 {
		mmSetStatusAndCreateEvent.mock.t.Fatalf("Some expectations are already set for the orderRepository.SetStatusAndCreateEvent method")
	}

	mmSetStatusAndCreateEvent.mock.funcSetStatusAndCreateEvent = f
	mmSetStatusAndCreateEvent.mock.funcSetStatusAndCreateEventOrigin = minimock.CallerInfo(1)
	return mmSetStatusAndCreateEvent.mock
}

// When sets expectation for the orderRepository.SetStatusAndCreateEvent which will trigger the result defined by the following
// Then helper
func (mmSetStatusAndCreateEvent *mOrderRepositoryMockSetStatusAndCreateEvent) When(ctx context.Context, orderID int64, status domain.OrderStatus, event domain.Event) *OrderRepositoryMockSetStatusAndCreateEventExpectation {
	if mmSetStatusAndCreateEvent.mock.funcSetStatusAndCreateEvent != nil {
		mmSetStatusAndCreateEvent.mock.t.Fatalf("OrderRepositoryMock.SetStatusAndCreateEvent mock is already set by Set")
	}

	expectation := &OrderRepositoryMockSetStatusAndCreateEventExpectation{
		mock:               mmSetStatusAndCreateEvent.mock,
		params:             &OrderRepositoryMockSetStatusAndCreateEventParams{ctx, orderID, status, event},
		expectationOrigins: OrderRepositoryMockSetStatusAndCreateEventExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetStatusAndCreateEvent.expectations = append(mmSetStatusAndCreateEvent.expectations, expectation)
	return expectation
}

// Then sets up orderRepository.SetStatusAndCreateEvent return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockSetStatusAndCreateEventExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockSetStatusAndCreateEventResults{err}
	return e.mock
}

// Times sets number of times orderRepository.SetStatusAndCreateEvent should be invoked
func (mmSetStatusAndCreateEvent *mOrderRepositoryMockSetStatusAndCreateEvent) Times(n uint64) *mOrderRepositoryMockSetStatusAndCreateEvent {
	if n == 0 {
		mmSetStatusAndCreateEvent.mock.t.Fatalf("Times of OrderRepositoryMock.SetStatusAndCreateEvent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetStatusAndCreateEvent.expectedInvocations, n)
	mmSetStatusAndCreateEvent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetStatusAndCreateEvent
}

func (mmSetStatusAndCreateEvent *mOrderRepositoryMockSetStatusAndCreateEvent) invocationsDone() bool {
	if len(mmSetStatusAndCreateEvent.expectations) == 0 && mmSetStatusAndCreateEvent.defaultExpectation == nil && mmSetStatusAndCreateEvent.mock.funcSetStatusAndCreateEvent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetStatusAndCreateEvent.mock.afterSetStatusAndCreateEventCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetStatusAndCreateEvent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetStatusAndCreateEvent implements mm_order.orderRepository
func (mmSetStatusAndCreateEvent *OrderRepositoryMock) SetStatusAndCreateEvent(ctx context.Context, orderID int64, status domain.OrderStatus, event domain.Event) (err error) {
	mm_atomic.AddUint64(&mmSetStatusAndCreateEvent.beforeSetStatusAndCreateEventCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatusAndCreateEvent.afterSetStatusAndCreateEventCounter, 1)

	mmSetStatusAndCreateEvent.t.Helper()

	if mmSetStatusAndCreateEvent.inspectFuncSetStatusAndCreateEvent != nil {
		mmSetStatusAndCreateEvent.inspectFuncSetStatusAndCreateEvent(ctx, orderID, status, event)
	}

	mm_params := OrderRepositoryMockSetStatusAndCreateEventParams{ctx, orderID, status, event}

	// Record call args
	mmSetStatusAndCreateEvent.SetStatusAndCreateEventMock.mutex.Lock()
	mmSetStatusAndCreateEvent.SetStatusAndCreateEventMock.callArgs = append(mmSetStatusAndCreateEvent.SetStatusAndCreateEventMock.callArgs, &mm_params)
	mmSetStatusAndCreateEvent.SetStatusAndCreateEventMock.mutex.Unlock()

	for _, e := range mmSetStatusAndCreateEvent.SetStatusAndCreateEventMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStatusAndCreateEvent.SetStatusAndCreateEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatusAndCreateEvent.SetStatusAndCreateEventMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatusAndCreateEvent.SetStatusAndCreateEventMock.defaultExpectation.params
		mm_want_ptrs := mmSetStatusAndCreateEvent.SetStatusAndCreateEventMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockSetStatusAndCreateEventParams{ctx, orderID, status, event}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetStatusAndCreateEvent.t.Errorf("OrderRepositoryMock.SetStatusAndCreateEvent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatusAndCreateEvent.SetStatusAndCreateEventMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmSetStatusAndCreateEvent.t.Errorf("OrderRepositoryMock.SetStatusAndCreateEvent got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatusAndCreateEvent.SetStatusAndCreateEventMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmSetStatusAndCreateEvent.t.Errorf("OrderRepositoryMock.SetStatusAndCreateEvent got unexpected parameter status, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatusAndCreateEvent.SetStatusAndCreateEventMock.defaultExpectation.expectationOrigins.originStatus, *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

			if mm_want_ptrs.event != nil && !minimock.Equal(*mm_want_ptrs.event, mm_got.event) {
				mmSetStatusAndCreateEvent.t.Errorf("OrderRepositoryMock.SetStatusAndCreateEvent got unexpected parameter event, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatusAndCreateEvent.SetStatusAndCreateEventMock.defaultExpectation.expectationOrigins.originEvent, *mm_want_ptrs.event, mm_got.event, minimock.Diff(*mm_want_ptrs.event, mm_got.event))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatusAndCreateEvent.t.Errorf("OrderRepositoryMock.SetStatusAndCreateEvent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetStatusAndCreateEvent.SetStatusAndCreateEventMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStatusAndCreateEvent.SetStatusAndCreateEventMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStatusAndCreateEvent.t.Fatal("No results are set for the OrderRepositoryMock.SetStatusAndCreateEvent")
		}
		return (*mm_results).err
	}
	if mmSetStatusAndCreateEvent.funcSetStatusAndCreateEvent != nil {
		return mmSetStatusAndCreateEvent.funcSetStatusAndCreateEvent(ctx, orderID, status, event)
	}
	mmSetStatusAndCreateEvent.t.Fatalf("Unexpected call to OrderRepositoryMock.SetStatusAndCreateEvent. %v %v %v %v", ctx, orderID, status, event)
	return
}

// SetStatusAndCreateEventAfterCounter returns a count of finished OrderRepositoryMock.SetStatusAndCreateEvent invocations
func (mmSetStatusAndCreateEvent *OrderRepositoryMock) SetStatusAndCreateEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatusAndCreateEvent.afterSetStatusAndCreateEventCounter)
}

// SetStatusAndCreateEventBeforeCounter returns a count of OrderRepositoryMock.SetStatusAndCreateEvent invocations
func (mmSetStatusAndCreateEvent *OrderRepositoryMock) SetStatusAndCreateEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatusAndCreateEvent.beforeSetStatusAndCreateEventCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.SetStatusAndCreateEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatusAndCreateEvent *mOrderRepositoryMockSetStatusAndCreateEvent) Calls() []*OrderRepositoryMockSetStatusAndCreateEventParams {
	mmSetStatusAndCreateEvent.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockSetStatusAndCreateEventParams, len(mmSetStatusAndCreateEvent.callArgs))
	copy(argCopy, mmSetStatusAndCreateEvent.callArgs)

	mmSetStatusAndCreateEvent.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusAndCreateEventDone returns true if the count of the SetStatusAndCreateEvent invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockSetStatusAndCreateEventDone() bool {
	if m.SetStatusAndCreateEventMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStatusAndCreateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStatusAndCreateEventMock.invocationsDone()
}

// MinimockSetStatusAndCreateEventInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockSetStatusAndCreateEventInspect() {
	for _, e := range m.SetStatusAndCreateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.SetStatusAndCreateEvent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetStatusAndCreateEventCounter := mm_atomic.LoadUint64(&m.afterSetStatusAndCreateEventCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusAndCreateEventMock.defaultExpectation != nil && afterSetStatusAndCreateEventCounter < 1 {
		if m.SetStatusAndCreateEventMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.SetStatusAndCreateEvent at\n%s", m.SetStatusAndCreateEventMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.SetStatusAndCreateEvent at\n%s with params: %#v", m.SetStatusAndCreateEventMock.defaultExpectation.expectationOrigins.origin, *m.SetStatusAndCreateEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatusAndCreateEvent != nil && afterSetStatusAndCreateEventCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.SetStatusAndCreateEvent at\n%s", m.funcSetStatusAndCreateEventOrigin)
	}

	if !m.SetStatusAndCreateEventMock.invocationsDone() && afterSetStatusAndCreateEventCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.SetStatusAndCreateEvent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetStatusAndCreateEventMock.expectedInvocations), m.SetStatusAndCreateEventMock.expectedInvocationsOrigin, afterSetStatusAndCreateEventCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateOrderInspect()

			m.MinimockCreateOrderItemsInspect()

			m.MinimockGetByOrderIDInspect()

			m.MinimockGetByOrderIDForUpdateInspect()

			m.MinimockSetStatusInspect()

			m.MinimockSetStatusAndCreateEventInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateOrderDone() &&
		m.MinimockCreateOrderItemsDone() &&
		m.MinimockGetByOrderIDDone() &&
		m.MinimockGetByOrderIDForUpdateDone() &&
		m.MinimockSetStatusDone() &&
		m.MinimockSetStatusAndCreateEventDone()
}
