// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	"context"
	"route256/loms/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StockRepositoryMock implements mm_stock.stockRepository
type StockRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetStockBySku          func(ctx context.Context, sku domain.Sku) (s1 domain.Stock, err error)
	funcGetStockBySkuOrigin    string
	inspectFuncGetStockBySku   func(ctx context.Context, sku domain.Sku)
	afterGetStockBySkuCounter  uint64
	beforeGetStockBySkuCounter uint64
	GetStockBySkuMock          mStockRepositoryMockGetStockBySku

	funcGetStocksBySkuForUpdate          func(ctx context.Context, items []domain.Item) (m1 map[domain.Sku]domain.Stock, err error)
	funcGetStocksBySkuForUpdateOrigin    string
	inspectFuncGetStocksBySkuForUpdate   func(ctx context.Context, items []domain.Item)
	afterGetStocksBySkuForUpdateCounter  uint64
	beforeGetStocksBySkuForUpdateCounter uint64
	GetStocksBySkuForUpdateMock          mStockRepositoryMockGetStocksBySkuForUpdate

	funcUpdateStocks          func(ctx context.Context, stocks map[domain.Sku]domain.Stock) (err error)
	funcUpdateStocksOrigin    string
	inspectFuncUpdateStocks   func(ctx context.Context, stocks map[domain.Sku]domain.Stock)
	afterUpdateStocksCounter  uint64
	beforeUpdateStocksCounter uint64
	UpdateStocksMock          mStockRepositoryMockUpdateStocks
}

// NewStockRepositoryMock returns a mock for mm_stock.stockRepository
func NewStockRepositoryMock(t minimock.Tester) *StockRepositoryMock {
	m := &StockRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetStockBySkuMock = mStockRepositoryMockGetStockBySku{mock: m}
	m.GetStockBySkuMock.callArgs = []*StockRepositoryMockGetStockBySkuParams{}

	m.GetStocksBySkuForUpdateMock = mStockRepositoryMockGetStocksBySkuForUpdate{mock: m}
	m.GetStocksBySkuForUpdateMock.callArgs = []*StockRepositoryMockGetStocksBySkuForUpdateParams{}

	m.UpdateStocksMock = mStockRepositoryMockUpdateStocks{mock: m}
	m.UpdateStocksMock.callArgs = []*StockRepositoryMockUpdateStocksParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStockRepositoryMockGetStockBySku struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockGetStockBySkuExpectation
	expectations       []*StockRepositoryMockGetStockBySkuExpectation

	callArgs []*StockRepositoryMockGetStockBySkuParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockRepositoryMockGetStockBySkuExpectation specifies expectation struct of the stockRepository.GetStockBySku
type StockRepositoryMockGetStockBySkuExpectation struct {
	mock               *StockRepositoryMock
	params             *StockRepositoryMockGetStockBySkuParams
	paramPtrs          *StockRepositoryMockGetStockBySkuParamPtrs
	expectationOrigins StockRepositoryMockGetStockBySkuExpectationOrigins
	results            *StockRepositoryMockGetStockBySkuResults
	returnOrigin       string
	Counter            uint64
}

// StockRepositoryMockGetStockBySkuParams contains parameters of the stockRepository.GetStockBySku
type StockRepositoryMockGetStockBySkuParams struct {
	ctx context.Context
	sku domain.Sku
}

// StockRepositoryMockGetStockBySkuParamPtrs contains pointers to parameters of the stockRepository.GetStockBySku
type StockRepositoryMockGetStockBySkuParamPtrs struct {
	ctx *context.Context
	sku *domain.Sku
}

// StockRepositoryMockGetStockBySkuResults contains results of the stockRepository.GetStockBySku
type StockRepositoryMockGetStockBySkuResults struct {
	s1  domain.Stock
	err error
}

// StockRepositoryMockGetStockBySkuOrigins contains origins of expectations of the stockRepository.GetStockBySku
type StockRepositoryMockGetStockBySkuExpectationOrigins struct {
	origin    string
	originCtx string
	originSku string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetStockBySku *mStockRepositoryMockGetStockBySku) Optional() *mStockRepositoryMockGetStockBySku {
	mmGetStockBySku.optional = true
	return mmGetStockBySku
}

// Expect sets up expected params for stockRepository.GetStockBySku
func (mmGetStockBySku *mStockRepositoryMockGetStockBySku) Expect(ctx context.Context, sku domain.Sku) *mStockRepositoryMockGetStockBySku {
	if mmGetStockBySku.mock.funcGetStockBySku != nil {
		mmGetStockBySku.mock.t.Fatalf("StockRepositoryMock.GetStockBySku mock is already set by Set")
	}

	if mmGetStockBySku.defaultExpectation == nil {
		mmGetStockBySku.defaultExpectation = &StockRepositoryMockGetStockBySkuExpectation{}
	}

	if mmGetStockBySku.defaultExpectation.paramPtrs != nil {
		mmGetStockBySku.mock.t.Fatalf("StockRepositoryMock.GetStockBySku mock is already set by ExpectParams functions")
	}

	mmGetStockBySku.defaultExpectation.params = &StockRepositoryMockGetStockBySkuParams{ctx, sku}
	mmGetStockBySku.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetStockBySku.expectations {
		if minimock.Equal(e.params, mmGetStockBySku.defaultExpectation.params) {
			mmGetStockBySku.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetStockBySku.defaultExpectation.params)
		}
	}

	return mmGetStockBySku
}

// ExpectCtxParam1 sets up expected param ctx for stockRepository.GetStockBySku
func (mmGetStockBySku *mStockRepositoryMockGetStockBySku) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockGetStockBySku {
	if mmGetStockBySku.mock.funcGetStockBySku != nil {
		mmGetStockBySku.mock.t.Fatalf("StockRepositoryMock.GetStockBySku mock is already set by Set")
	}

	if mmGetStockBySku.defaultExpectation == nil {
		mmGetStockBySku.defaultExpectation = &StockRepositoryMockGetStockBySkuExpectation{}
	}

	if mmGetStockBySku.defaultExpectation.params != nil {
		mmGetStockBySku.mock.t.Fatalf("StockRepositoryMock.GetStockBySku mock is already set by Expect")
	}

	if mmGetStockBySku.defaultExpectation.paramPtrs == nil {
		mmGetStockBySku.defaultExpectation.paramPtrs = &StockRepositoryMockGetStockBySkuParamPtrs{}
	}
	mmGetStockBySku.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetStockBySku.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetStockBySku
}

// ExpectSkuParam2 sets up expected param sku for stockRepository.GetStockBySku
func (mmGetStockBySku *mStockRepositoryMockGetStockBySku) ExpectSkuParam2(sku domain.Sku) *mStockRepositoryMockGetStockBySku {
	if mmGetStockBySku.mock.funcGetStockBySku != nil {
		mmGetStockBySku.mock.t.Fatalf("StockRepositoryMock.GetStockBySku mock is already set by Set")
	}

	if mmGetStockBySku.defaultExpectation == nil {
		mmGetStockBySku.defaultExpectation = &StockRepositoryMockGetStockBySkuExpectation{}
	}

	if mmGetStockBySku.defaultExpectation.params != nil {
		mmGetStockBySku.mock.t.Fatalf("StockRepositoryMock.GetStockBySku mock is already set by Expect")
	}

	if mmGetStockBySku.defaultExpectation.paramPtrs == nil {
		mmGetStockBySku.defaultExpectation.paramPtrs = &StockRepositoryMockGetStockBySkuParamPtrs{}
	}
	mmGetStockBySku.defaultExpectation.paramPtrs.sku = &sku
	mmGetStockBySku.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmGetStockBySku
}

// Inspect accepts an inspector function that has same arguments as the stockRepository.GetStockBySku
func (mmGetStockBySku *mStockRepositoryMockGetStockBySku) Inspect(f func(ctx context.Context, sku domain.Sku)) *mStockRepositoryMockGetStockBySku {
	if mmGetStockBySku.mock.inspectFuncGetStockBySku != nil {
		mmGetStockBySku.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.GetStockBySku")
	}

	mmGetStockBySku.mock.inspectFuncGetStockBySku = f

	return mmGetStockBySku
}

// Return sets up results that will be returned by stockRepository.GetStockBySku
func (mmGetStockBySku *mStockRepositoryMockGetStockBySku) Return(s1 domain.Stock, err error) *StockRepositoryMock {
	if mmGetStockBySku.mock.funcGetStockBySku != nil {
		mmGetStockBySku.mock.t.Fatalf("StockRepositoryMock.GetStockBySku mock is already set by Set")
	}

	if mmGetStockBySku.defaultExpectation == nil {
		mmGetStockBySku.defaultExpectation = &StockRepositoryMockGetStockBySkuExpectation{mock: mmGetStockBySku.mock}
	}
	mmGetStockBySku.defaultExpectation.results = &StockRepositoryMockGetStockBySkuResults{s1, err}
	mmGetStockBySku.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetStockBySku.mock
}

// Set uses given function f to mock the stockRepository.GetStockBySku method
func (mmGetStockBySku *mStockRepositoryMockGetStockBySku) Set(f func(ctx context.Context, sku domain.Sku) (s1 domain.Stock, err error)) *StockRepositoryMock {
	if mmGetStockBySku.defaultExpectation != nil {
		mmGetStockBySku.mock.t.Fatalf("Default expectation is already set for the stockRepository.GetStockBySku method")
	}

	if len(mmGetStockBySku.expectations) > 0 {
		mmGetStockBySku.mock.t.Fatalf("Some expectations are already set for the stockRepository.GetStockBySku method")
	}

	mmGetStockBySku.mock.funcGetStockBySku = f
	mmGetStockBySku.mock.funcGetStockBySkuOrigin = minimock.CallerInfo(1)
	return mmGetStockBySku.mock
}

// When sets expectation for the stockRepository.GetStockBySku which will trigger the result defined by the following
// Then helper
func (mmGetStockBySku *mStockRepositoryMockGetStockBySku) When(ctx context.Context, sku domain.Sku) *StockRepositoryMockGetStockBySkuExpectation {
	if mmGetStockBySku.mock.funcGetStockBySku != nil {
		mmGetStockBySku.mock.t.Fatalf("StockRepositoryMock.GetStockBySku mock is already set by Set")
	}

	expectation := &StockRepositoryMockGetStockBySkuExpectation{
		mock:               mmGetStockBySku.mock,
		params:             &StockRepositoryMockGetStockBySkuParams{ctx, sku},
		expectationOrigins: StockRepositoryMockGetStockBySkuExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetStockBySku.expectations = append(mmGetStockBySku.expectations, expectation)
	return expectation
}

// Then sets up stockRepository.GetStockBySku return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockGetStockBySkuExpectation) Then(s1 domain.Stock, err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockGetStockBySkuResults{s1, err}
	return e.mock
}

// Times sets number of times stockRepository.GetStockBySku should be invoked
func (mmGetStockBySku *mStockRepositoryMockGetStockBySku) Times(n uint64) *mStockRepositoryMockGetStockBySku {
	if n == 0 {
		mmGetStockBySku.mock.t.Fatalf("Times of StockRepositoryMock.GetStockBySku mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetStockBySku.expectedInvocations, n)
	mmGetStockBySku.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetStockBySku
}

func (mmGetStockBySku *mStockRepositoryMockGetStockBySku) invocationsDone() bool {
	if len(mmGetStockBySku.expectations) == 0 && mmGetStockBySku.defaultExpectation == nil && mmGetStockBySku.mock.funcGetStockBySku == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetStockBySku.mock.afterGetStockBySkuCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetStockBySku.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetStockBySku implements mm_stock.stockRepository
func (mmGetStockBySku *StockRepositoryMock) GetStockBySku(ctx context.Context, sku domain.Sku) (s1 domain.Stock, err error) {
	mm_atomic.AddUint64(&mmGetStockBySku.beforeGetStockBySkuCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStockBySku.afterGetStockBySkuCounter, 1)

	mmGetStockBySku.t.Helper()

	if mmGetStockBySku.inspectFuncGetStockBySku != nil {
		mmGetStockBySku.inspectFuncGetStockBySku(ctx, sku)
	}

	mm_params := StockRepositoryMockGetStockBySkuParams{ctx, sku}

	// Record call args
	mmGetStockBySku.GetStockBySkuMock.mutex.Lock()
	mmGetStockBySku.GetStockBySkuMock.callArgs = append(mmGetStockBySku.GetStockBySkuMock.callArgs, &mm_params)
	mmGetStockBySku.GetStockBySkuMock.mutex.Unlock()

	for _, e := range mmGetStockBySku.GetStockBySkuMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetStockBySku.GetStockBySkuMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStockBySku.GetStockBySkuMock.defaultExpectation.Counter, 1)
		mm_want := mmGetStockBySku.GetStockBySkuMock.defaultExpectation.params
		mm_want_ptrs := mmGetStockBySku.GetStockBySkuMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockGetStockBySkuParams{ctx, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetStockBySku.t.Errorf("StockRepositoryMock.GetStockBySku got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStockBySku.GetStockBySkuMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmGetStockBySku.t.Errorf("StockRepositoryMock.GetStockBySku got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStockBySku.GetStockBySkuMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetStockBySku.t.Errorf("StockRepositoryMock.GetStockBySku got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetStockBySku.GetStockBySkuMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetStockBySku.GetStockBySkuMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStockBySku.t.Fatal("No results are set for the StockRepositoryMock.GetStockBySku")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetStockBySku.funcGetStockBySku != nil {
		return mmGetStockBySku.funcGetStockBySku(ctx, sku)
	}
	mmGetStockBySku.t.Fatalf("Unexpected call to StockRepositoryMock.GetStockBySku. %v %v", ctx, sku)
	return
}

// GetStockBySkuAfterCounter returns a count of finished StockRepositoryMock.GetStockBySku invocations
func (mmGetStockBySku *StockRepositoryMock) GetStockBySkuAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStockBySku.afterGetStockBySkuCounter)
}

// GetStockBySkuBeforeCounter returns a count of StockRepositoryMock.GetStockBySku invocations
func (mmGetStockBySku *StockRepositoryMock) GetStockBySkuBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStockBySku.beforeGetStockBySkuCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.GetStockBySku.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetStockBySku *mStockRepositoryMockGetStockBySku) Calls() []*StockRepositoryMockGetStockBySkuParams {
	mmGetStockBySku.mutex.RLock()

	argCopy := make([]*StockRepositoryMockGetStockBySkuParams, len(mmGetStockBySku.callArgs))
	copy(argCopy, mmGetStockBySku.callArgs)

	mmGetStockBySku.mutex.RUnlock()

	return argCopy
}

// MinimockGetStockBySkuDone returns true if the count of the GetStockBySku invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockGetStockBySkuDone() bool {
	if m.GetStockBySkuMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetStockBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetStockBySkuMock.invocationsDone()
}

// MinimockGetStockBySkuInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockGetStockBySkuInspect() {
	for _, e := range m.GetStockBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.GetStockBySku at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetStockBySkuCounter := mm_atomic.LoadUint64(&m.afterGetStockBySkuCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetStockBySkuMock.defaultExpectation != nil && afterGetStockBySkuCounter < 1 {
		if m.GetStockBySkuMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockRepositoryMock.GetStockBySku at\n%s", m.GetStockBySkuMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.GetStockBySku at\n%s with params: %#v", m.GetStockBySkuMock.defaultExpectation.expectationOrigins.origin, *m.GetStockBySkuMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStockBySku != nil && afterGetStockBySkuCounter < 1 {
		m.t.Errorf("Expected call to StockRepositoryMock.GetStockBySku at\n%s", m.funcGetStockBySkuOrigin)
	}

	if !m.GetStockBySkuMock.invocationsDone() && afterGetStockBySkuCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.GetStockBySku at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetStockBySkuMock.expectedInvocations), m.GetStockBySkuMock.expectedInvocationsOrigin, afterGetStockBySkuCounter)
	}
}

type mStockRepositoryMockGetStocksBySkuForUpdate struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockGetStocksBySkuForUpdateExpectation
	expectations       []*StockRepositoryMockGetStocksBySkuForUpdateExpectation

	callArgs []*StockRepositoryMockGetStocksBySkuForUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockRepositoryMockGetStocksBySkuForUpdateExpectation specifies expectation struct of the stockRepository.GetStocksBySkuForUpdate
type StockRepositoryMockGetStocksBySkuForUpdateExpectation struct {
	mock               *StockRepositoryMock
	params             *StockRepositoryMockGetStocksBySkuForUpdateParams
	paramPtrs          *StockRepositoryMockGetStocksBySkuForUpdateParamPtrs
	expectationOrigins StockRepositoryMockGetStocksBySkuForUpdateExpectationOrigins
	results            *StockRepositoryMockGetStocksBySkuForUpdateResults
	returnOrigin       string
	Counter            uint64
}

// StockRepositoryMockGetStocksBySkuForUpdateParams contains parameters of the stockRepository.GetStocksBySkuForUpdate
type StockRepositoryMockGetStocksBySkuForUpdateParams struct {
	ctx   context.Context
	items []domain.Item
}

// StockRepositoryMockGetStocksBySkuForUpdateParamPtrs contains pointers to parameters of the stockRepository.GetStocksBySkuForUpdate
type StockRepositoryMockGetStocksBySkuForUpdateParamPtrs struct {
	ctx   *context.Context
	items *[]domain.Item
}

// StockRepositoryMockGetStocksBySkuForUpdateResults contains results of the stockRepository.GetStocksBySkuForUpdate
type StockRepositoryMockGetStocksBySkuForUpdateResults struct {
	m1  map[domain.Sku]domain.Stock
	err error
}

// StockRepositoryMockGetStocksBySkuForUpdateOrigins contains origins of expectations of the stockRepository.GetStocksBySkuForUpdate
type StockRepositoryMockGetStocksBySkuForUpdateExpectationOrigins struct {
	origin      string
	originCtx   string
	originItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetStocksBySkuForUpdate *mStockRepositoryMockGetStocksBySkuForUpdate) Optional() *mStockRepositoryMockGetStocksBySkuForUpdate {
	mmGetStocksBySkuForUpdate.optional = true
	return mmGetStocksBySkuForUpdate
}

// Expect sets up expected params for stockRepository.GetStocksBySkuForUpdate
func (mmGetStocksBySkuForUpdate *mStockRepositoryMockGetStocksBySkuForUpdate) Expect(ctx context.Context, items []domain.Item) *mStockRepositoryMockGetStocksBySkuForUpdate {
	if mmGetStocksBySkuForUpdate.mock.funcGetStocksBySkuForUpdate != nil {
		mmGetStocksBySkuForUpdate.mock.t.Fatalf("StockRepositoryMock.GetStocksBySkuForUpdate mock is already set by Set")
	}

	if mmGetStocksBySkuForUpdate.defaultExpectation == nil {
		mmGetStocksBySkuForUpdate.defaultExpectation = &StockRepositoryMockGetStocksBySkuForUpdateExpectation{}
	}

	if mmGetStocksBySkuForUpdate.defaultExpectation.paramPtrs != nil {
		mmGetStocksBySkuForUpdate.mock.t.Fatalf("StockRepositoryMock.GetStocksBySkuForUpdate mock is already set by ExpectParams functions")
	}

	mmGetStocksBySkuForUpdate.defaultExpectation.params = &StockRepositoryMockGetStocksBySkuForUpdateParams{ctx, items}
	mmGetStocksBySkuForUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetStocksBySkuForUpdate.expectations {
		if minimock.Equal(e.params, mmGetStocksBySkuForUpdate.defaultExpectation.params) {
			mmGetStocksBySkuForUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetStocksBySkuForUpdate.defaultExpectation.params)
		}
	}

	return mmGetStocksBySkuForUpdate
}

// ExpectCtxParam1 sets up expected param ctx for stockRepository.GetStocksBySkuForUpdate
func (mmGetStocksBySkuForUpdate *mStockRepositoryMockGetStocksBySkuForUpdate) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockGetStocksBySkuForUpdate {
	if mmGetStocksBySkuForUpdate.mock.funcGetStocksBySkuForUpdate != nil {
		mmGetStocksBySkuForUpdate.mock.t.Fatalf("StockRepositoryMock.GetStocksBySkuForUpdate mock is already set by Set")
	}

	if mmGetStocksBySkuForUpdate.defaultExpectation == nil {
		mmGetStocksBySkuForUpdate.defaultExpectation = &StockRepositoryMockGetStocksBySkuForUpdateExpectation{}
	}

	if mmGetStocksBySkuForUpdate.defaultExpectation.params != nil {
		mmGetStocksBySkuForUpdate.mock.t.Fatalf("StockRepositoryMock.GetStocksBySkuForUpdate mock is already set by Expect")
	}

	if mmGetStocksBySkuForUpdate.defaultExpectation.paramPtrs == nil {
		mmGetStocksBySkuForUpdate.defaultExpectation.paramPtrs = &StockRepositoryMockGetStocksBySkuForUpdateParamPtrs{}
	}
	mmGetStocksBySkuForUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetStocksBySkuForUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetStocksBySkuForUpdate
}

// ExpectItemsParam2 sets up expected param items for stockRepository.GetStocksBySkuForUpdate
func (mmGetStocksBySkuForUpdate *mStockRepositoryMockGetStocksBySkuForUpdate) ExpectItemsParam2(items []domain.Item) *mStockRepositoryMockGetStocksBySkuForUpdate {
	if mmGetStocksBySkuForUpdate.mock.funcGetStocksBySkuForUpdate != nil {
		mmGetStocksBySkuForUpdate.mock.t.Fatalf("StockRepositoryMock.GetStocksBySkuForUpdate mock is already set by Set")
	}

	if mmGetStocksBySkuForUpdate.defaultExpectation == nil {
		mmGetStocksBySkuForUpdate.defaultExpectation = &StockRepositoryMockGetStocksBySkuForUpdateExpectation{}
	}

	if mmGetStocksBySkuForUpdate.defaultExpectation.params != nil {
		mmGetStocksBySkuForUpdate.mock.t.Fatalf("StockRepositoryMock.GetStocksBySkuForUpdate mock is already set by Expect")
	}

	if mmGetStocksBySkuForUpdate.defaultExpectation.paramPtrs == nil {
		mmGetStocksBySkuForUpdate.defaultExpectation.paramPtrs = &StockRepositoryMockGetStocksBySkuForUpdateParamPtrs{}
	}
	mmGetStocksBySkuForUpdate.defaultExpectation.paramPtrs.items = &items
	mmGetStocksBySkuForUpdate.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmGetStocksBySkuForUpdate
}

// Inspect accepts an inspector function that has same arguments as the stockRepository.GetStocksBySkuForUpdate
func (mmGetStocksBySkuForUpdate *mStockRepositoryMockGetStocksBySkuForUpdate) Inspect(f func(ctx context.Context, items []domain.Item)) *mStockRepositoryMockGetStocksBySkuForUpdate {
	if mmGetStocksBySkuForUpdate.mock.inspectFuncGetStocksBySkuForUpdate != nil {
		mmGetStocksBySkuForUpdate.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.GetStocksBySkuForUpdate")
	}

	mmGetStocksBySkuForUpdate.mock.inspectFuncGetStocksBySkuForUpdate = f

	return mmGetStocksBySkuForUpdate
}

// Return sets up results that will be returned by stockRepository.GetStocksBySkuForUpdate
func (mmGetStocksBySkuForUpdate *mStockRepositoryMockGetStocksBySkuForUpdate) Return(m1 map[domain.Sku]domain.Stock, err error) *StockRepositoryMock {
	if mmGetStocksBySkuForUpdate.mock.funcGetStocksBySkuForUpdate != nil {
		mmGetStocksBySkuForUpdate.mock.t.Fatalf("StockRepositoryMock.GetStocksBySkuForUpdate mock is already set by Set")
	}

	if mmGetStocksBySkuForUpdate.defaultExpectation == nil {
		mmGetStocksBySkuForUpdate.defaultExpectation = &StockRepositoryMockGetStocksBySkuForUpdateExpectation{mock: mmGetStocksBySkuForUpdate.mock}
	}
	mmGetStocksBySkuForUpdate.defaultExpectation.results = &StockRepositoryMockGetStocksBySkuForUpdateResults{m1, err}
	mmGetStocksBySkuForUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetStocksBySkuForUpdate.mock
}

// Set uses given function f to mock the stockRepository.GetStocksBySkuForUpdate method
func (mmGetStocksBySkuForUpdate *mStockRepositoryMockGetStocksBySkuForUpdate) Set(f func(ctx context.Context, items []domain.Item) (m1 map[domain.Sku]domain.Stock, err error)) *StockRepositoryMock {
	if mmGetStocksBySkuForUpdate.defaultExpectation != nil {
		mmGetStocksBySkuForUpdate.mock.t.Fatalf("Default expectation is already set for the stockRepository.GetStocksBySkuForUpdate method")
	}

	if len(mmGetStocksBySkuForUpdate.expectations) > 0 {
		mmGetStocksBySkuForUpdate.mock.t.Fatalf("Some expectations are already set for the stockRepository.GetStocksBySkuForUpdate method")
	}

	mmGetStocksBySkuForUpdate.mock.funcGetStocksBySkuForUpdate = f
	mmGetStocksBySkuForUpdate.mock.funcGetStocksBySkuForUpdateOrigin = minimock.CallerInfo(1)
	return mmGetStocksBySkuForUpdate.mock
}

// When sets expectation for the stockRepository.GetStocksBySkuForUpdate which will trigger the result defined by the following
// Then helper
func (mmGetStocksBySkuForUpdate *mStockRepositoryMockGetStocksBySkuForUpdate) When(ctx context.Context, items []domain.Item) *StockRepositoryMockGetStocksBySkuForUpdateExpectation {
	if mmGetStocksBySkuForUpdate.mock.funcGetStocksBySkuForUpdate != nil {
		mmGetStocksBySkuForUpdate.mock.t.Fatalf("StockRepositoryMock.GetStocksBySkuForUpdate mock is already set by Set")
	}

	expectation := &StockRepositoryMockGetStocksBySkuForUpdateExpectation{
		mock:               mmGetStocksBySkuForUpdate.mock,
		params:             &StockRepositoryMockGetStocksBySkuForUpdateParams{ctx, items},
		expectationOrigins: StockRepositoryMockGetStocksBySkuForUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetStocksBySkuForUpdate.expectations = append(mmGetStocksBySkuForUpdate.expectations, expectation)
	return expectation
}

// Then sets up stockRepository.GetStocksBySkuForUpdate return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockGetStocksBySkuForUpdateExpectation) Then(m1 map[domain.Sku]domain.Stock, err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockGetStocksBySkuForUpdateResults{m1, err}
	return e.mock
}

// Times sets number of times stockRepository.GetStocksBySkuForUpdate should be invoked
func (mmGetStocksBySkuForUpdate *mStockRepositoryMockGetStocksBySkuForUpdate) Times(n uint64) *mStockRepositoryMockGetStocksBySkuForUpdate {
	if n == 0 {
		mmGetStocksBySkuForUpdate.mock.t.Fatalf("Times of StockRepositoryMock.GetStocksBySkuForUpdate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetStocksBySkuForUpdate.expectedInvocations, n)
	mmGetStocksBySkuForUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetStocksBySkuForUpdate
}

func (mmGetStocksBySkuForUpdate *mStockRepositoryMockGetStocksBySkuForUpdate) invocationsDone() bool {
	if len(mmGetStocksBySkuForUpdate.expectations) == 0 && mmGetStocksBySkuForUpdate.defaultExpectation == nil && mmGetStocksBySkuForUpdate.mock.funcGetStocksBySkuForUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetStocksBySkuForUpdate.mock.afterGetStocksBySkuForUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetStocksBySkuForUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetStocksBySkuForUpdate implements mm_stock.stockRepository
func (mmGetStocksBySkuForUpdate *StockRepositoryMock) GetStocksBySkuForUpdate(ctx context.Context, items []domain.Item) (m1 map[domain.Sku]domain.Stock, err error) {
	mm_atomic.AddUint64(&mmGetStocksBySkuForUpdate.beforeGetStocksBySkuForUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStocksBySkuForUpdate.afterGetStocksBySkuForUpdateCounter, 1)

	mmGetStocksBySkuForUpdate.t.Helper()

	if mmGetStocksBySkuForUpdate.inspectFuncGetStocksBySkuForUpdate != nil {
		mmGetStocksBySkuForUpdate.inspectFuncGetStocksBySkuForUpdate(ctx, items)
	}

	mm_params := StockRepositoryMockGetStocksBySkuForUpdateParams{ctx, items}

	// Record call args
	mmGetStocksBySkuForUpdate.GetStocksBySkuForUpdateMock.mutex.Lock()
	mmGetStocksBySkuForUpdate.GetStocksBySkuForUpdateMock.callArgs = append(mmGetStocksBySkuForUpdate.GetStocksBySkuForUpdateMock.callArgs, &mm_params)
	mmGetStocksBySkuForUpdate.GetStocksBySkuForUpdateMock.mutex.Unlock()

	for _, e := range mmGetStocksBySkuForUpdate.GetStocksBySkuForUpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetStocksBySkuForUpdate.GetStocksBySkuForUpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStocksBySkuForUpdate.GetStocksBySkuForUpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmGetStocksBySkuForUpdate.GetStocksBySkuForUpdateMock.defaultExpectation.params
		mm_want_ptrs := mmGetStocksBySkuForUpdate.GetStocksBySkuForUpdateMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockGetStocksBySkuForUpdateParams{ctx, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetStocksBySkuForUpdate.t.Errorf("StockRepositoryMock.GetStocksBySkuForUpdate got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStocksBySkuForUpdate.GetStocksBySkuForUpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmGetStocksBySkuForUpdate.t.Errorf("StockRepositoryMock.GetStocksBySkuForUpdate got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStocksBySkuForUpdate.GetStocksBySkuForUpdateMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetStocksBySkuForUpdate.t.Errorf("StockRepositoryMock.GetStocksBySkuForUpdate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetStocksBySkuForUpdate.GetStocksBySkuForUpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetStocksBySkuForUpdate.GetStocksBySkuForUpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStocksBySkuForUpdate.t.Fatal("No results are set for the StockRepositoryMock.GetStocksBySkuForUpdate")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetStocksBySkuForUpdate.funcGetStocksBySkuForUpdate != nil {
		return mmGetStocksBySkuForUpdate.funcGetStocksBySkuForUpdate(ctx, items)
	}
	mmGetStocksBySkuForUpdate.t.Fatalf("Unexpected call to StockRepositoryMock.GetStocksBySkuForUpdate. %v %v", ctx, items)
	return
}

// GetStocksBySkuForUpdateAfterCounter returns a count of finished StockRepositoryMock.GetStocksBySkuForUpdate invocations
func (mmGetStocksBySkuForUpdate *StockRepositoryMock) GetStocksBySkuForUpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStocksBySkuForUpdate.afterGetStocksBySkuForUpdateCounter)
}

// GetStocksBySkuForUpdateBeforeCounter returns a count of StockRepositoryMock.GetStocksBySkuForUpdate invocations
func (mmGetStocksBySkuForUpdate *StockRepositoryMock) GetStocksBySkuForUpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStocksBySkuForUpdate.beforeGetStocksBySkuForUpdateCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.GetStocksBySkuForUpdate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetStocksBySkuForUpdate *mStockRepositoryMockGetStocksBySkuForUpdate) Calls() []*StockRepositoryMockGetStocksBySkuForUpdateParams {
	mmGetStocksBySkuForUpdate.mutex.RLock()

	argCopy := make([]*StockRepositoryMockGetStocksBySkuForUpdateParams, len(mmGetStocksBySkuForUpdate.callArgs))
	copy(argCopy, mmGetStocksBySkuForUpdate.callArgs)

	mmGetStocksBySkuForUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockGetStocksBySkuForUpdateDone returns true if the count of the GetStocksBySkuForUpdate invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockGetStocksBySkuForUpdateDone() bool {
	if m.GetStocksBySkuForUpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetStocksBySkuForUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetStocksBySkuForUpdateMock.invocationsDone()
}

// MinimockGetStocksBySkuForUpdateInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockGetStocksBySkuForUpdateInspect() {
	for _, e := range m.GetStocksBySkuForUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.GetStocksBySkuForUpdate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetStocksBySkuForUpdateCounter := mm_atomic.LoadUint64(&m.afterGetStocksBySkuForUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetStocksBySkuForUpdateMock.defaultExpectation != nil && afterGetStocksBySkuForUpdateCounter < 1 {
		if m.GetStocksBySkuForUpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockRepositoryMock.GetStocksBySkuForUpdate at\n%s", m.GetStocksBySkuForUpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.GetStocksBySkuForUpdate at\n%s with params: %#v", m.GetStocksBySkuForUpdateMock.defaultExpectation.expectationOrigins.origin, *m.GetStocksBySkuForUpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStocksBySkuForUpdate != nil && afterGetStocksBySkuForUpdateCounter < 1 {
		m.t.Errorf("Expected call to StockRepositoryMock.GetStocksBySkuForUpdate at\n%s", m.funcGetStocksBySkuForUpdateOrigin)
	}

	if !m.GetStocksBySkuForUpdateMock.invocationsDone() && afterGetStocksBySkuForUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.GetStocksBySkuForUpdate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetStocksBySkuForUpdateMock.expectedInvocations), m.GetStocksBySkuForUpdateMock.expectedInvocationsOrigin, afterGetStocksBySkuForUpdateCounter)
	}
}

type mStockRepositoryMockUpdateStocks struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockUpdateStocksExpectation
	expectations       []*StockRepositoryMockUpdateStocksExpectation

	callArgs []*StockRepositoryMockUpdateStocksParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockRepositoryMockUpdateStocksExpectation specifies expectation struct of the stockRepository.UpdateStocks
type StockRepositoryMockUpdateStocksExpectation struct {
	mock               *StockRepositoryMock
	params             *StockRepositoryMockUpdateStocksParams
	paramPtrs          *StockRepositoryMockUpdateStocksParamPtrs
	expectationOrigins StockRepositoryMockUpdateStocksExpectationOrigins
	results            *StockRepositoryMockUpdateStocksResults
	returnOrigin       string
	Counter            uint64
}

// StockRepositoryMockUpdateStocksParams contains parameters of the stockRepository.UpdateStocks
type StockRepositoryMockUpdateStocksParams struct {
	ctx    context.Context
	stocks map[domain.Sku]domain.Stock
}

// StockRepositoryMockUpdateStocksParamPtrs contains pointers to parameters of the stockRepository.UpdateStocks
type StockRepositoryMockUpdateStocksParamPtrs struct {
	ctx    *context.Context
	stocks *map[domain.Sku]domain.Stock
}

// StockRepositoryMockUpdateStocksResults contains results of the stockRepository.UpdateStocks
type StockRepositoryMockUpdateStocksResults struct {
	err error
}

// StockRepositoryMockUpdateStocksOrigins contains origins of expectations of the stockRepository.UpdateStocks
type StockRepositoryMockUpdateStocksExpectationOrigins struct {
	origin       string
	originCtx    string
	originStocks string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateStocks *mStockRepositoryMockUpdateStocks) Optional() *mStockRepositoryMockUpdateStocks {
	mmUpdateStocks.optional = true
	return mmUpdateStocks
}

// Expect sets up expected params for stockRepository.UpdateStocks
func (mmUpdateStocks *mStockRepositoryMockUpdateStocks) Expect(ctx context.Context, stocks map[domain.Sku]domain.Stock) *mStockRepositoryMockUpdateStocks {
	if mmUpdateStocks.mock.funcUpdateStocks != nil {
		mmUpdateStocks.mock.t.Fatalf("StockRepositoryMock.UpdateStocks mock is already set by Set")
	}

	if mmUpdateStocks.defaultExpectation == nil {
		mmUpdateStocks.defaultExpectation = &StockRepositoryMockUpdateStocksExpectation{}
	}

	if mmUpdateStocks.defaultExpectation.paramPtrs != nil {
		mmUpdateStocks.mock.t.Fatalf("StockRepositoryMock.UpdateStocks mock is already set by ExpectParams functions")
	}

	mmUpdateStocks.defaultExpectation.params = &StockRepositoryMockUpdateStocksParams{ctx, stocks}
	mmUpdateStocks.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateStocks.expectations {
		if minimock.Equal(e.params, mmUpdateStocks.defaultExpectation.params) {
			mmUpdateStocks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateStocks.defaultExpectation.params)
		}
	}

	return mmUpdateStocks
}

// ExpectCtxParam1 sets up expected param ctx for stockRepository.UpdateStocks
func (mmUpdateStocks *mStockRepositoryMockUpdateStocks) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockUpdateStocks {
	if mmUpdateStocks.mock.funcUpdateStocks != nil {
		mmUpdateStocks.mock.t.Fatalf("StockRepositoryMock.UpdateStocks mock is already set by Set")
	}

	if mmUpdateStocks.defaultExpectation == nil {
		mmUpdateStocks.defaultExpectation = &StockRepositoryMockUpdateStocksExpectation{}
	}

	if mmUpdateStocks.defaultExpectation.params != nil {
		mmUpdateStocks.mock.t.Fatalf("StockRepositoryMock.UpdateStocks mock is already set by Expect")
	}

	if mmUpdateStocks.defaultExpectation.paramPtrs == nil {
		mmUpdateStocks.defaultExpectation.paramPtrs = &StockRepositoryMockUpdateStocksParamPtrs{}
	}
	mmUpdateStocks.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateStocks.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateStocks
}

// ExpectStocksParam2 sets up expected param stocks for stockRepository.UpdateStocks
func (mmUpdateStocks *mStockRepositoryMockUpdateStocks) ExpectStocksParam2(stocks map[domain.Sku]domain.Stock) *mStockRepositoryMockUpdateStocks {
	if mmUpdateStocks.mock.funcUpdateStocks != nil {
		mmUpdateStocks.mock.t.Fatalf("StockRepositoryMock.UpdateStocks mock is already set by Set")
	}

	if mmUpdateStocks.defaultExpectation == nil {
		mmUpdateStocks.defaultExpectation = &StockRepositoryMockUpdateStocksExpectation{}
	}

	if mmUpdateStocks.defaultExpectation.params != nil {
		mmUpdateStocks.mock.t.Fatalf("StockRepositoryMock.UpdateStocks mock is already set by Expect")
	}

	if mmUpdateStocks.defaultExpectation.paramPtrs == nil {
		mmUpdateStocks.defaultExpectation.paramPtrs = &StockRepositoryMockUpdateStocksParamPtrs{}
	}
	mmUpdateStocks.defaultExpectation.paramPtrs.stocks = &stocks
	mmUpdateStocks.defaultExpectation.expectationOrigins.originStocks = minimock.CallerInfo(1)

	return mmUpdateStocks
}

// Inspect accepts an inspector function that has same arguments as the stockRepository.UpdateStocks
func (mmUpdateStocks *mStockRepositoryMockUpdateStocks) Inspect(f func(ctx context.Context, stocks map[domain.Sku]domain.Stock)) *mStockRepositoryMockUpdateStocks {
	if mmUpdateStocks.mock.inspectFuncUpdateStocks != nil {
		mmUpdateStocks.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.UpdateStocks")
	}

	mmUpdateStocks.mock.inspectFuncUpdateStocks = f

	return mmUpdateStocks
}

// Return sets up results that will be returned by stockRepository.UpdateStocks
func (mmUpdateStocks *mStockRepositoryMockUpdateStocks) Return(err error) *StockRepositoryMock {
	if mmUpdateStocks.mock.funcUpdateStocks != nil {
		mmUpdateStocks.mock.t.Fatalf("StockRepositoryMock.UpdateStocks mock is already set by Set")
	}

	if mmUpdateStocks.defaultExpectation == nil {
		mmUpdateStocks.defaultExpectation = &StockRepositoryMockUpdateStocksExpectation{mock: mmUpdateStocks.mock}
	}
	mmUpdateStocks.defaultExpectation.results = &StockRepositoryMockUpdateStocksResults{err}
	mmUpdateStocks.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateStocks.mock
}

// Set uses given function f to mock the stockRepository.UpdateStocks method
func (mmUpdateStocks *mStockRepositoryMockUpdateStocks) Set(f func(ctx context.Context, stocks map[domain.Sku]domain.Stock) (err error)) *StockRepositoryMock {
	if mmUpdateStocks.defaultExpectation != nil {
		mmUpdateStocks.mock.t.Fatalf("Default expectation is already set for the stockRepository.UpdateStocks method")
	}

	if len(mmUpdateStocks.expectations) > 0 {
		mmUpdateStocks.mock.t.Fatalf("Some expectations are already set for the stockRepository.UpdateStocks method")
	}

	mmUpdateStocks.mock.funcUpdateStocks = f
	mmUpdateStocks.mock.funcUpdateStocksOrigin = minimock.CallerInfo(1)
	return mmUpdateStocks.mock
}

// When sets expectation for the stockRepository.UpdateStocks which will trigger the result defined by the following
// Then helper
func (mmUpdateStocks *mStockRepositoryMockUpdateStocks) When(ctx context.Context, stocks map[domain.Sku]domain.Stock) *StockRepositoryMockUpdateStocksExpectation {
	if mmUpdateStocks.mock.funcUpdateStocks != nil {
		mmUpdateStocks.mock.t.Fatalf("StockRepositoryMock.UpdateStocks mock is already set by Set")
	}

	expectation := &StockRepositoryMockUpdateStocksExpectation{
		mock:               mmUpdateStocks.mock,
		params:             &StockRepositoryMockUpdateStocksParams{ctx, stocks},
		expectationOrigins: StockRepositoryMockUpdateStocksExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateStocks.expectations = append(mmUpdateStocks.expectations, expectation)
	return expectation
}

// Then sets up stockRepository.UpdateStocks return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockUpdateStocksExpectation) Then(err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockUpdateStocksResults{err}
	return e.mock
}

// Times sets number of times stockRepository.UpdateStocks should be invoked
func (mmUpdateStocks *mStockRepositoryMockUpdateStocks) Times(n uint64) *mStockRepositoryMockUpdateStocks {
	if n == 0 {
		mmUpdateStocks.mock.t.Fatalf("Times of StockRepositoryMock.UpdateStocks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateStocks.expectedInvocations, n)
	mmUpdateStocks.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateStocks
}

func (mmUpdateStocks *mStockRepositoryMockUpdateStocks) invocationsDone() bool {
	if len(mmUpdateStocks.expectations) == 0 && mmUpdateStocks.defaultExpectation == nil && mmUpdateStocks.mock.funcUpdateStocks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateStocks.mock.afterUpdateStocksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateStocks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateStocks implements mm_stock.stockRepository
func (mmUpdateStocks *StockRepositoryMock) UpdateStocks(ctx context.Context, stocks map[domain.Sku]domain.Stock) (err error) {
	mm_atomic.AddUint64(&mmUpdateStocks.beforeUpdateStocksCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateStocks.afterUpdateStocksCounter, 1)

	mmUpdateStocks.t.Helper()

	if mmUpdateStocks.inspectFuncUpdateStocks != nil {
		mmUpdateStocks.inspectFuncUpdateStocks(ctx, stocks)
	}

	mm_params := StockRepositoryMockUpdateStocksParams{ctx, stocks}

	// Record call args
	mmUpdateStocks.UpdateStocksMock.mutex.Lock()
	mmUpdateStocks.UpdateStocksMock.callArgs = append(mmUpdateStocks.UpdateStocksMock.callArgs, &mm_params)
	mmUpdateStocks.UpdateStocksMock.mutex.Unlock()

	for _, e := range mmUpdateStocks.UpdateStocksMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateStocks.UpdateStocksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateStocks.UpdateStocksMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateStocks.UpdateStocksMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateStocks.UpdateStocksMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockUpdateStocksParams{ctx, stocks}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateStocks.t.Errorf("StockRepositoryMock.UpdateStocks got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateStocks.UpdateStocksMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.stocks != nil && !minimock.Equal(*mm_want_ptrs.stocks, mm_got.stocks) {
				mmUpdateStocks.t.Errorf("StockRepositoryMock.UpdateStocks got unexpected parameter stocks, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateStocks.UpdateStocksMock.defaultExpectation.expectationOrigins.originStocks, *mm_want_ptrs.stocks, mm_got.stocks, minimock.Diff(*mm_want_ptrs.stocks, mm_got.stocks))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateStocks.t.Errorf("StockRepositoryMock.UpdateStocks got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateStocks.UpdateStocksMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateStocks.UpdateStocksMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateStocks.t.Fatal("No results are set for the StockRepositoryMock.UpdateStocks")
		}
		return (*mm_results).err
	}
	if mmUpdateStocks.funcUpdateStocks != nil {
		return mmUpdateStocks.funcUpdateStocks(ctx, stocks)
	}
	mmUpdateStocks.t.Fatalf("Unexpected call to StockRepositoryMock.UpdateStocks. %v %v", ctx, stocks)
	return
}

// UpdateStocksAfterCounter returns a count of finished StockRepositoryMock.UpdateStocks invocations
func (mmUpdateStocks *StockRepositoryMock) UpdateStocksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStocks.afterUpdateStocksCounter)
}

// UpdateStocksBeforeCounter returns a count of StockRepositoryMock.UpdateStocks invocations
func (mmUpdateStocks *StockRepositoryMock) UpdateStocksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStocks.beforeUpdateStocksCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.UpdateStocks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateStocks *mStockRepositoryMockUpdateStocks) Calls() []*StockRepositoryMockUpdateStocksParams {
	mmUpdateStocks.mutex.RLock()

	argCopy := make([]*StockRepositoryMockUpdateStocksParams, len(mmUpdateStocks.callArgs))
	copy(argCopy, mmUpdateStocks.callArgs)

	mmUpdateStocks.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateStocksDone returns true if the count of the UpdateStocks invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockUpdateStocksDone() bool {
	if m.UpdateStocksMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateStocksMock.invocationsDone()
}

// MinimockUpdateStocksInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockUpdateStocksInspect() {
	for _, e := range m.UpdateStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.UpdateStocks at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateStocksCounter := mm_atomic.LoadUint64(&m.afterUpdateStocksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateStocksMock.defaultExpectation != nil && afterUpdateStocksCounter < 1 {
		if m.UpdateStocksMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockRepositoryMock.UpdateStocks at\n%s", m.UpdateStocksMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.UpdateStocks at\n%s with params: %#v", m.UpdateStocksMock.defaultExpectation.expectationOrigins.origin, *m.UpdateStocksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateStocks != nil && afterUpdateStocksCounter < 1 {
		m.t.Errorf("Expected call to StockRepositoryMock.UpdateStocks at\n%s", m.funcUpdateStocksOrigin)
	}

	if !m.UpdateStocksMock.invocationsDone() && afterUpdateStocksCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.UpdateStocks at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateStocksMock.expectedInvocations), m.UpdateStocksMock.expectedInvocationsOrigin, afterUpdateStocksCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StockRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetStockBySkuInspect()

			m.MinimockGetStocksBySkuForUpdateInspect()

			m.MinimockUpdateStocksInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StockRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StockRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetStockBySkuDone() &&
		m.MinimockGetStocksBySkuForUpdateDone() &&
		m.MinimockUpdateStocksDone()
}
