// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: orders.sql

package repository_sqlc

import (
	"context"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (user_id)
VALUES ($1)
RETURNING id
`

func (q *Queries) CreateOrder(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, createOrder, userID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createOrderItems = `-- name: CreateOrderItems :exec
INSERT INTO order_items (order_id, sku, count)
SELECT unnest($1::bigint[]), unnest($2::bigint[]), unnest($3::bigint[])
`

type CreateOrderItemsParams struct {
	OrderIds []int64
	Skus     []int64
	Counts   []int64
}

func (q *Queries) CreateOrderItems(ctx context.Context, arg *CreateOrderItemsParams) error {
	_, err := q.db.Exec(ctx, createOrderItems, arg.OrderIds, arg.Skus, arg.Counts)
	return err
}

const getByOrderID = `-- name: GetByOrderID :many
SELECT 
    o.user_id,
    o.status,
    oi.sku,
    oi.count
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
WHERE o.id = $1
`

type GetByOrderIDRow struct {
	UserID int64
	Status OrderStatus
	Sku    int64
	Count  int64
}

func (q *Queries) GetByOrderID(ctx context.Context, id int64) ([]*GetByOrderIDRow, error) {
	rows, err := q.db.Query(ctx, getByOrderID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetByOrderIDRow
	for rows.Next() {
		var i GetByOrderIDRow
		if err := rows.Scan(
			&i.UserID,
			&i.Status,
			&i.Sku,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getByOrderIDForUpdate = `-- name: GetByOrderIDForUpdate :many
SELECT 
    o.user_id,
    o.status,
    oi.sku,
    oi.count
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
WHERE o.id = $1
FOR UPDATE
`

type GetByOrderIDForUpdateRow struct {
	UserID int64
	Status OrderStatus
	Sku    int64
	Count  int64
}

func (q *Queries) GetByOrderIDForUpdate(ctx context.Context, id int64) ([]*GetByOrderIDForUpdateRow, error) {
	rows, err := q.db.Query(ctx, getByOrderIDForUpdate, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetByOrderIDForUpdateRow
	for rows.Next() {
		var i GetByOrderIDForUpdateRow
		if err := rows.Scan(
			&i.UserID,
			&i.Status,
			&i.Sku,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setStatus = `-- name: SetStatus :exec
UPDATE orders
SET status = $1,
    updated_at = NOW()
WHERE id = $2
`

type SetStatusParams struct {
	Status OrderStatus
	ID     int64
}

func (q *Queries) SetStatus(ctx context.Context, arg *SetStatusParams) error {
	_, err := q.db.Exec(ctx, setStatus, arg.Status, arg.ID)
	return err
}
