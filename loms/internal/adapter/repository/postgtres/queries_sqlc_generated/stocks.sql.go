// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: stocks.sql

package repository_sqlc

import (
	"context"
)

const getStockBySku = `-- name: GetStockBySku :one
SELECT sku, total_count, reserved
FROM stocks
WHERE sku = $1
`

type GetStockBySkuRow struct {
	Sku        int64
	TotalCount int64
	Reserved   int64
}

func (q *Queries) GetStockBySku(ctx context.Context, sku int64) (*GetStockBySkuRow, error) {
	row := q.db.QueryRow(ctx, getStockBySku, sku)
	var i GetStockBySkuRow
	err := row.Scan(&i.Sku, &i.TotalCount, &i.Reserved)
	return &i, err
}

const getStocksBySkuForUpdate = `-- name: GetStocksBySkuForUpdate :many
SELECT sku, total_count, reserved 
FROM stocks 
WHERE sku = ANY($1::bigint[]) FOR UPDATE
`

type GetStocksBySkuForUpdateRow struct {
	Sku        int64
	TotalCount int64
	Reserved   int64
}

func (q *Queries) GetStocksBySkuForUpdate(ctx context.Context, sku []int64) ([]*GetStocksBySkuForUpdateRow, error) {
	rows, err := q.db.Query(ctx, getStocksBySkuForUpdate, sku)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetStocksBySkuForUpdateRow
	for rows.Next() {
		var i GetStocksBySkuForUpdateRow
		if err := rows.Scan(&i.Sku, &i.TotalCount, &i.Reserved); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStocks = `-- name: UpdateStocks :exec
UPDATE stocks s
SET
    total_count = u.total_count,
    reserved = u.reserved,
    updated_at = now()
FROM (
    SELECT 
        unnest($1::bigint[]) AS sku,
        unnest($2::bigint[]) AS total_count,
        unnest($3::bigint[]) AS reserved
) AS u
WHERE s.sku = u.sku
`

type UpdateStocksParams struct {
	Sku        []int64
	TotalCount []int64
	Reserved   []int64
}

func (q *Queries) UpdateStocks(ctx context.Context, arg *UpdateStocksParams) error {
	_, err := q.db.Exec(ctx, updateStocks, arg.Sku, arg.TotalCount, arg.Reserved)
	return err
}
