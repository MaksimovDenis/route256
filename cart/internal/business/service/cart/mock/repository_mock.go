// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	"context"
	"route256/cart/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements mm_cart.repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItem          func(ctx context.Context, userID uint64, cart domain.Item) (err error)
	funcAddItemOrigin    string
	inspectFuncAddItem   func(ctx context.Context, userID uint64, cart domain.Item)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mRepositoryMockAddItem

	funcDeleteItem          func(ctx context.Context, userID uint64, sku domain.Sku) (err error)
	funcDeleteItemOrigin    string
	inspectFuncDeleteItem   func(ctx context.Context, userID uint64, sku domain.Sku)
	afterDeleteItemCounter  uint64
	beforeDeleteItemCounter uint64
	DeleteItemMock          mRepositoryMockDeleteItem

	funcDeleteItemsByUserID          func(ctx context.Context, userID uint64) (err error)
	funcDeleteItemsByUserIDOrigin    string
	inspectFuncDeleteItemsByUserID   func(ctx context.Context, userID uint64)
	afterDeleteItemsByUserIDCounter  uint64
	beforeDeleteItemsByUserIDCounter uint64
	DeleteItemsByUserIDMock          mRepositoryMockDeleteItemsByUserID

	funcGetItemOfUserIDBySku          func(ctx context.Context, userID uint64, sku domain.Sku) (i1 domain.Item, err error)
	funcGetItemOfUserIDBySkuOrigin    string
	inspectFuncGetItemOfUserIDBySku   func(ctx context.Context, userID uint64, sku domain.Sku)
	afterGetItemOfUserIDBySkuCounter  uint64
	beforeGetItemOfUserIDBySkuCounter uint64
	GetItemOfUserIDBySkuMock          mRepositoryMockGetItemOfUserIDBySku

	funcGetItemsByUserID          func(ctx context.Context, userID uint64) (ia1 []domain.Item, err error)
	funcGetItemsByUserIDOrigin    string
	inspectFuncGetItemsByUserID   func(ctx context.Context, userID uint64)
	afterGetItemsByUserIDCounter  uint64
	beforeGetItemsByUserIDCounter uint64
	GetItemsByUserIDMock          mRepositoryMockGetItemsByUserID
}

// NewRepositoryMock returns a mock for mm_cart.repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mRepositoryMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*RepositoryMockAddItemParams{}

	m.DeleteItemMock = mRepositoryMockDeleteItem{mock: m}
	m.DeleteItemMock.callArgs = []*RepositoryMockDeleteItemParams{}

	m.DeleteItemsByUserIDMock = mRepositoryMockDeleteItemsByUserID{mock: m}
	m.DeleteItemsByUserIDMock.callArgs = []*RepositoryMockDeleteItemsByUserIDParams{}

	m.GetItemOfUserIDBySkuMock = mRepositoryMockGetItemOfUserIDBySku{mock: m}
	m.GetItemOfUserIDBySkuMock.callArgs = []*RepositoryMockGetItemOfUserIDBySkuParams{}

	m.GetItemsByUserIDMock = mRepositoryMockGetItemsByUserID{mock: m}
	m.GetItemsByUserIDMock.callArgs = []*RepositoryMockGetItemsByUserIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockAddItem struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddItemExpectation
	expectations       []*RepositoryMockAddItemExpectation

	callArgs []*RepositoryMockAddItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockAddItemExpectation specifies expectation struct of the repository.AddItem
type RepositoryMockAddItemExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockAddItemParams
	paramPtrs          *RepositoryMockAddItemParamPtrs
	expectationOrigins RepositoryMockAddItemExpectationOrigins
	results            *RepositoryMockAddItemResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockAddItemParams contains parameters of the repository.AddItem
type RepositoryMockAddItemParams struct {
	ctx    context.Context
	userID uint64
	cart   domain.Item
}

// RepositoryMockAddItemParamPtrs contains pointers to parameters of the repository.AddItem
type RepositoryMockAddItemParamPtrs struct {
	ctx    *context.Context
	userID *uint64
	cart   *domain.Item
}

// RepositoryMockAddItemResults contains results of the repository.AddItem
type RepositoryMockAddItemResults struct {
	err error
}

// RepositoryMockAddItemOrigins contains origins of expectations of the repository.AddItem
type RepositoryMockAddItemExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originCart   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItem *mRepositoryMockAddItem) Optional() *mRepositoryMockAddItem {
	mmAddItem.optional = true
	return mmAddItem
}

// Expect sets up expected params for repository.AddItem
func (mmAddItem *mRepositoryMockAddItem) Expect(ctx context.Context, userID uint64, cart domain.Item) *mRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &RepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.paramPtrs != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by ExpectParams functions")
	}

	mmAddItem.defaultExpectation.params = &RepositoryMockAddItemParams{ctx, userID, cart}
	mmAddItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// ExpectCtxParam1 sets up expected param ctx for repository.AddItem
func (mmAddItem *mRepositoryMockAddItem) ExpectCtxParam1(ctx context.Context) *mRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &RepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &RepositoryMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectUserIDParam2 sets up expected param userID for repository.AddItem
func (mmAddItem *mRepositoryMockAddItem) ExpectUserIDParam2(userID uint64) *mRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &RepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &RepositoryMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.userID = &userID
	mmAddItem.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectCartParam3 sets up expected param cart for repository.AddItem
func (mmAddItem *mRepositoryMockAddItem) ExpectCartParam3(cart domain.Item) *mRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &RepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &RepositoryMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.cart = &cart
	mmAddItem.defaultExpectation.expectationOrigins.originCart = minimock.CallerInfo(1)

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the repository.AddItem
func (mmAddItem *mRepositoryMockAddItem) Inspect(f func(ctx context.Context, userID uint64, cart domain.Item)) *mRepositoryMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by repository.AddItem
func (mmAddItem *mRepositoryMockAddItem) Return(err error) *RepositoryMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &RepositoryMockAddItemExpectation{mock: mmAddItem.mock}
	}
	mmAddItem.defaultExpectation.results = &RepositoryMockAddItemResults{err}
	mmAddItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// Set uses given function f to mock the repository.AddItem method
func (mmAddItem *mRepositoryMockAddItem) Set(f func(ctx context.Context, userID uint64, cart domain.Item) (err error)) *RepositoryMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the repository.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the repository.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	mmAddItem.mock.funcAddItemOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// When sets expectation for the repository.AddItem which will trigger the result defined by the following
// Then helper
func (mmAddItem *mRepositoryMockAddItem) When(ctx context.Context, userID uint64, cart domain.Item) *RepositoryMockAddItemExpectation {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by Set")
	}

	expectation := &RepositoryMockAddItemExpectation{
		mock:               mmAddItem.mock,
		params:             &RepositoryMockAddItemParams{ctx, userID, cart},
		expectationOrigins: RepositoryMockAddItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddItem.expectations = append(mmAddItem.expectations, expectation)
	return expectation
}

// Then sets up repository.AddItem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddItemExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockAddItemResults{err}
	return e.mock
}

// Times sets number of times repository.AddItem should be invoked
func (mmAddItem *mRepositoryMockAddItem) Times(n uint64) *mRepositoryMockAddItem {
	if n == 0 {
		mmAddItem.mock.t.Fatalf("Times of RepositoryMock.AddItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddItem.expectedInvocations, n)
	mmAddItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddItem
}

func (mmAddItem *mRepositoryMockAddItem) invocationsDone() bool {
	if len(mmAddItem.expectations) == 0 && mmAddItem.defaultExpectation == nil && mmAddItem.mock.funcAddItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddItem.mock.afterAddItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddItem implements mm_cart.repository
func (mmAddItem *RepositoryMock) AddItem(ctx context.Context, userID uint64, cart domain.Item) (err error) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	mmAddItem.t.Helper()

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(ctx, userID, cart)
	}

	mm_params := RepositoryMockAddItemParams{ctx, userID, cart}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, &mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_want_ptrs := mmAddItem.AddItemMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockAddItemParams{ctx, userID, cart}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddItem.t.Errorf("RepositoryMock.AddItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmAddItem.t.Errorf("RepositoryMock.AddItem got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.cart != nil && !minimock.Equal(*mm_want_ptrs.cart, mm_got.cart) {
				mmAddItem.t.Errorf("RepositoryMock.AddItem got unexpected parameter cart, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originCart, *mm_want_ptrs.cart, mm_got.cart, minimock.Diff(*mm_want_ptrs.cart, mm_got.cart))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("RepositoryMock.AddItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItem.AddItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItem.t.Fatal("No results are set for the RepositoryMock.AddItem")
		}
		return (*mm_results).err
	}
	if mmAddItem.funcAddItem != nil {
		return mmAddItem.funcAddItem(ctx, userID, cart)
	}
	mmAddItem.t.Fatalf("Unexpected call to RepositoryMock.AddItem. %v %v %v", ctx, userID, cart)
	return
}

// AddItemAfterCounter returns a count of finished RepositoryMock.AddItem invocations
func (mmAddItem *RepositoryMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of RepositoryMock.AddItem invocations
func (mmAddItem *RepositoryMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mRepositoryMockAddItem) Calls() []*RepositoryMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*RepositoryMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddItemDone() bool {
	if m.AddItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddItemMock.invocationsDone()
}

// MinimockAddItemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddItemCounter := mm_atomic.LoadUint64(&m.afterAddItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && afterAddItemCounter < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.AddItem at\n%s", m.AddItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddItem at\n%s with params: %#v", m.AddItemMock.defaultExpectation.expectationOrigins.origin, *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && afterAddItemCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.AddItem at\n%s", m.funcAddItemOrigin)
	}

	if !m.AddItemMock.invocationsDone() && afterAddItemCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.AddItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddItemMock.expectedInvocations), m.AddItemMock.expectedInvocationsOrigin, afterAddItemCounter)
	}
}

type mRepositoryMockDeleteItem struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteItemExpectation
	expectations       []*RepositoryMockDeleteItemExpectation

	callArgs []*RepositoryMockDeleteItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteItemExpectation specifies expectation struct of the repository.DeleteItem
type RepositoryMockDeleteItemExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteItemParams
	paramPtrs          *RepositoryMockDeleteItemParamPtrs
	expectationOrigins RepositoryMockDeleteItemExpectationOrigins
	results            *RepositoryMockDeleteItemResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteItemParams contains parameters of the repository.DeleteItem
type RepositoryMockDeleteItemParams struct {
	ctx    context.Context
	userID uint64
	sku    domain.Sku
}

// RepositoryMockDeleteItemParamPtrs contains pointers to parameters of the repository.DeleteItem
type RepositoryMockDeleteItemParamPtrs struct {
	ctx    *context.Context
	userID *uint64
	sku    *domain.Sku
}

// RepositoryMockDeleteItemResults contains results of the repository.DeleteItem
type RepositoryMockDeleteItemResults struct {
	err error
}

// RepositoryMockDeleteItemOrigins contains origins of expectations of the repository.DeleteItem
type RepositoryMockDeleteItemExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originSku    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItem *mRepositoryMockDeleteItem) Optional() *mRepositoryMockDeleteItem {
	mmDeleteItem.optional = true
	return mmDeleteItem
}

// Expect sets up expected params for repository.DeleteItem
func (mmDeleteItem *mRepositoryMockDeleteItem) Expect(ctx context.Context, userID uint64, sku domain.Sku) *mRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &RepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.paramPtrs != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by ExpectParams functions")
	}

	mmDeleteItem.defaultExpectation.params = &RepositoryMockDeleteItemParams{ctx, userID, sku}
	mmDeleteItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteItem.expectations {
		if minimock.Equal(e.params, mmDeleteItem.defaultExpectation.params) {
			mmDeleteItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItem.defaultExpectation.params)
		}
	}

	return mmDeleteItem
}

// ExpectCtxParam1 sets up expected param ctx for repository.DeleteItem
func (mmDeleteItem *mRepositoryMockDeleteItem) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &RepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &RepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteItem
}

// ExpectUserIDParam2 sets up expected param userID for repository.DeleteItem
func (mmDeleteItem *mRepositoryMockDeleteItem) ExpectUserIDParam2(userID uint64) *mRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &RepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &RepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteItem.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteItem
}

// ExpectSkuParam3 sets up expected param sku for repository.DeleteItem
func (mmDeleteItem *mRepositoryMockDeleteItem) ExpectSkuParam3(sku domain.Sku) *mRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &RepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &RepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.sku = &sku
	mmDeleteItem.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmDeleteItem
}

// Inspect accepts an inspector function that has same arguments as the repository.DeleteItem
func (mmDeleteItem *mRepositoryMockDeleteItem) Inspect(f func(ctx context.Context, userID uint64, sku domain.Sku)) *mRepositoryMockDeleteItem {
	if mmDeleteItem.mock.inspectFuncDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteItem")
	}

	mmDeleteItem.mock.inspectFuncDeleteItem = f

	return mmDeleteItem
}

// Return sets up results that will be returned by repository.DeleteItem
func (mmDeleteItem *mRepositoryMockDeleteItem) Return(err error) *RepositoryMock {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &RepositoryMockDeleteItemExpectation{mock: mmDeleteItem.mock}
	}
	mmDeleteItem.defaultExpectation.results = &RepositoryMockDeleteItemResults{err}
	mmDeleteItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// Set uses given function f to mock the repository.DeleteItem method
func (mmDeleteItem *mRepositoryMockDeleteItem) Set(f func(ctx context.Context, userID uint64, sku domain.Sku) (err error)) *RepositoryMock {
	if mmDeleteItem.defaultExpectation != nil {
		mmDeleteItem.mock.t.Fatalf("Default expectation is already set for the repository.DeleteItem method")
	}

	if len(mmDeleteItem.expectations) > 0 {
		mmDeleteItem.mock.t.Fatalf("Some expectations are already set for the repository.DeleteItem method")
	}

	mmDeleteItem.mock.funcDeleteItem = f
	mmDeleteItem.mock.funcDeleteItemOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// When sets expectation for the repository.DeleteItem which will trigger the result defined by the following
// Then helper
func (mmDeleteItem *mRepositoryMockDeleteItem) When(ctx context.Context, userID uint64, sku domain.Sku) *RepositoryMockDeleteItemExpectation {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteItemExpectation{
		mock:               mmDeleteItem.mock,
		params:             &RepositoryMockDeleteItemParams{ctx, userID, sku},
		expectationOrigins: RepositoryMockDeleteItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteItem.expectations = append(mmDeleteItem.expectations, expectation)
	return expectation
}

// Then sets up repository.DeleteItem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteItemExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteItemResults{err}
	return e.mock
}

// Times sets number of times repository.DeleteItem should be invoked
func (mmDeleteItem *mRepositoryMockDeleteItem) Times(n uint64) *mRepositoryMockDeleteItem {
	if n == 0 {
		mmDeleteItem.mock.t.Fatalf("Times of RepositoryMock.DeleteItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItem.expectedInvocations, n)
	mmDeleteItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteItem
}

func (mmDeleteItem *mRepositoryMockDeleteItem) invocationsDone() bool {
	if len(mmDeleteItem.expectations) == 0 && mmDeleteItem.defaultExpectation == nil && mmDeleteItem.mock.funcDeleteItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItem.mock.afterDeleteItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItem implements mm_cart.repository
func (mmDeleteItem *RepositoryMock) DeleteItem(ctx context.Context, userID uint64, sku domain.Sku) (err error) {
	mm_atomic.AddUint64(&mmDeleteItem.beforeDeleteItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItem.afterDeleteItemCounter, 1)

	mmDeleteItem.t.Helper()

	if mmDeleteItem.inspectFuncDeleteItem != nil {
		mmDeleteItem.inspectFuncDeleteItem(ctx, userID, sku)
	}

	mm_params := RepositoryMockDeleteItemParams{ctx, userID, sku}

	// Record call args
	mmDeleteItem.DeleteItemMock.mutex.Lock()
	mmDeleteItem.DeleteItemMock.callArgs = append(mmDeleteItem.DeleteItemMock.callArgs, &mm_params)
	mmDeleteItem.DeleteItemMock.mutex.Unlock()

	for _, e := range mmDeleteItem.DeleteItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItem.DeleteItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItem.DeleteItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItem.DeleteItemMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItem.DeleteItemMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteItemParams{ctx, userID, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteItem.t.Errorf("RepositoryMock.DeleteItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteItem.t.Errorf("RepositoryMock.DeleteItem got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmDeleteItem.t.Errorf("RepositoryMock.DeleteItem got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItem.t.Errorf("RepositoryMock.DeleteItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItem.DeleteItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItem.t.Fatal("No results are set for the RepositoryMock.DeleteItem")
		}
		return (*mm_results).err
	}
	if mmDeleteItem.funcDeleteItem != nil {
		return mmDeleteItem.funcDeleteItem(ctx, userID, sku)
	}
	mmDeleteItem.t.Fatalf("Unexpected call to RepositoryMock.DeleteItem. %v %v %v", ctx, userID, sku)
	return
}

// DeleteItemAfterCounter returns a count of finished RepositoryMock.DeleteItem invocations
func (mmDeleteItem *RepositoryMock) DeleteItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.afterDeleteItemCounter)
}

// DeleteItemBeforeCounter returns a count of RepositoryMock.DeleteItem invocations
func (mmDeleteItem *RepositoryMock) DeleteItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.beforeDeleteItemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItem *mRepositoryMockDeleteItem) Calls() []*RepositoryMockDeleteItemParams {
	mmDeleteItem.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteItemParams, len(mmDeleteItem.callArgs))
	copy(argCopy, mmDeleteItem.callArgs)

	mmDeleteItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemDone returns true if the count of the DeleteItem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteItemDone() bool {
	if m.DeleteItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemMock.invocationsDone()
}

// MinimockDeleteItemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteItemInspect() {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteItemCounter := mm_atomic.LoadUint64(&m.afterDeleteItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && afterDeleteItemCounter < 1 {
		if m.DeleteItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteItem at\n%s", m.DeleteItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteItem at\n%s with params: %#v", m.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *m.DeleteItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && afterDeleteItemCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteItem at\n%s", m.funcDeleteItemOrigin)
	}

	if !m.DeleteItemMock.invocationsDone() && afterDeleteItemCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemMock.expectedInvocations), m.DeleteItemMock.expectedInvocationsOrigin, afterDeleteItemCounter)
	}
}

type mRepositoryMockDeleteItemsByUserID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteItemsByUserIDExpectation
	expectations       []*RepositoryMockDeleteItemsByUserIDExpectation

	callArgs []*RepositoryMockDeleteItemsByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteItemsByUserIDExpectation specifies expectation struct of the repository.DeleteItemsByUserID
type RepositoryMockDeleteItemsByUserIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteItemsByUserIDParams
	paramPtrs          *RepositoryMockDeleteItemsByUserIDParamPtrs
	expectationOrigins RepositoryMockDeleteItemsByUserIDExpectationOrigins
	results            *RepositoryMockDeleteItemsByUserIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteItemsByUserIDParams contains parameters of the repository.DeleteItemsByUserID
type RepositoryMockDeleteItemsByUserIDParams struct {
	ctx    context.Context
	userID uint64
}

// RepositoryMockDeleteItemsByUserIDParamPtrs contains pointers to parameters of the repository.DeleteItemsByUserID
type RepositoryMockDeleteItemsByUserIDParamPtrs struct {
	ctx    *context.Context
	userID *uint64
}

// RepositoryMockDeleteItemsByUserIDResults contains results of the repository.DeleteItemsByUserID
type RepositoryMockDeleteItemsByUserIDResults struct {
	err error
}

// RepositoryMockDeleteItemsByUserIDOrigins contains origins of expectations of the repository.DeleteItemsByUserID
type RepositoryMockDeleteItemsByUserIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItemsByUserID *mRepositoryMockDeleteItemsByUserID) Optional() *mRepositoryMockDeleteItemsByUserID {
	mmDeleteItemsByUserID.optional = true
	return mmDeleteItemsByUserID
}

// Expect sets up expected params for repository.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mRepositoryMockDeleteItemsByUserID) Expect(ctx context.Context, userID uint64) *mRepositoryMockDeleteItemsByUserID {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("RepositoryMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmDeleteItemsByUserID.defaultExpectation == nil {
		mmDeleteItemsByUserID.defaultExpectation = &RepositoryMockDeleteItemsByUserIDExpectation{}
	}

	if mmDeleteItemsByUserID.defaultExpectation.paramPtrs != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("RepositoryMock.DeleteItemsByUserID mock is already set by ExpectParams functions")
	}

	mmDeleteItemsByUserID.defaultExpectation.params = &RepositoryMockDeleteItemsByUserIDParams{ctx, userID}
	mmDeleteItemsByUserID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteItemsByUserID.expectations {
		if minimock.Equal(e.params, mmDeleteItemsByUserID.defaultExpectation.params) {
			mmDeleteItemsByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItemsByUserID.defaultExpectation.params)
		}
	}

	return mmDeleteItemsByUserID
}

// ExpectCtxParam1 sets up expected param ctx for repository.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mRepositoryMockDeleteItemsByUserID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteItemsByUserID {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("RepositoryMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmDeleteItemsByUserID.defaultExpectation == nil {
		mmDeleteItemsByUserID.defaultExpectation = &RepositoryMockDeleteItemsByUserIDExpectation{}
	}

	if mmDeleteItemsByUserID.defaultExpectation.params != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("RepositoryMock.DeleteItemsByUserID mock is already set by Expect")
	}

	if mmDeleteItemsByUserID.defaultExpectation.paramPtrs == nil {
		mmDeleteItemsByUserID.defaultExpectation.paramPtrs = &RepositoryMockDeleteItemsByUserIDParamPtrs{}
	}
	mmDeleteItemsByUserID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteItemsByUserID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteItemsByUserID
}

// ExpectUserIDParam2 sets up expected param userID for repository.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mRepositoryMockDeleteItemsByUserID) ExpectUserIDParam2(userID uint64) *mRepositoryMockDeleteItemsByUserID {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("RepositoryMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmDeleteItemsByUserID.defaultExpectation == nil {
		mmDeleteItemsByUserID.defaultExpectation = &RepositoryMockDeleteItemsByUserIDExpectation{}
	}

	if mmDeleteItemsByUserID.defaultExpectation.params != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("RepositoryMock.DeleteItemsByUserID mock is already set by Expect")
	}

	if mmDeleteItemsByUserID.defaultExpectation.paramPtrs == nil {
		mmDeleteItemsByUserID.defaultExpectation.paramPtrs = &RepositoryMockDeleteItemsByUserIDParamPtrs{}
	}
	mmDeleteItemsByUserID.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteItemsByUserID.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteItemsByUserID
}

// Inspect accepts an inspector function that has same arguments as the repository.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mRepositoryMockDeleteItemsByUserID) Inspect(f func(ctx context.Context, userID uint64)) *mRepositoryMockDeleteItemsByUserID {
	if mmDeleteItemsByUserID.mock.inspectFuncDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteItemsByUserID")
	}

	mmDeleteItemsByUserID.mock.inspectFuncDeleteItemsByUserID = f

	return mmDeleteItemsByUserID
}

// Return sets up results that will be returned by repository.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mRepositoryMockDeleteItemsByUserID) Return(err error) *RepositoryMock {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("RepositoryMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmDeleteItemsByUserID.defaultExpectation == nil {
		mmDeleteItemsByUserID.defaultExpectation = &RepositoryMockDeleteItemsByUserIDExpectation{mock: mmDeleteItemsByUserID.mock}
	}
	mmDeleteItemsByUserID.defaultExpectation.results = &RepositoryMockDeleteItemsByUserIDResults{err}
	mmDeleteItemsByUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteItemsByUserID.mock
}

// Set uses given function f to mock the repository.DeleteItemsByUserID method
func (mmDeleteItemsByUserID *mRepositoryMockDeleteItemsByUserID) Set(f func(ctx context.Context, userID uint64) (err error)) *RepositoryMock {
	if mmDeleteItemsByUserID.defaultExpectation != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("Default expectation is already set for the repository.DeleteItemsByUserID method")
	}

	if len(mmDeleteItemsByUserID.expectations) > 0 {
		mmDeleteItemsByUserID.mock.t.Fatalf("Some expectations are already set for the repository.DeleteItemsByUserID method")
	}

	mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID = f
	mmDeleteItemsByUserID.mock.funcDeleteItemsByUserIDOrigin = minimock.CallerInfo(1)
	return mmDeleteItemsByUserID.mock
}

// When sets expectation for the repository.DeleteItemsByUserID which will trigger the result defined by the following
// Then helper
func (mmDeleteItemsByUserID *mRepositoryMockDeleteItemsByUserID) When(ctx context.Context, userID uint64) *RepositoryMockDeleteItemsByUserIDExpectation {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("RepositoryMock.DeleteItemsByUserID mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteItemsByUserIDExpectation{
		mock:               mmDeleteItemsByUserID.mock,
		params:             &RepositoryMockDeleteItemsByUserIDParams{ctx, userID},
		expectationOrigins: RepositoryMockDeleteItemsByUserIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteItemsByUserID.expectations = append(mmDeleteItemsByUserID.expectations, expectation)
	return expectation
}

// Then sets up repository.DeleteItemsByUserID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteItemsByUserIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteItemsByUserIDResults{err}
	return e.mock
}

// Times sets number of times repository.DeleteItemsByUserID should be invoked
func (mmDeleteItemsByUserID *mRepositoryMockDeleteItemsByUserID) Times(n uint64) *mRepositoryMockDeleteItemsByUserID {
	if n == 0 {
		mmDeleteItemsByUserID.mock.t.Fatalf("Times of RepositoryMock.DeleteItemsByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItemsByUserID.expectedInvocations, n)
	mmDeleteItemsByUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteItemsByUserID
}

func (mmDeleteItemsByUserID *mRepositoryMockDeleteItemsByUserID) invocationsDone() bool {
	if len(mmDeleteItemsByUserID.expectations) == 0 && mmDeleteItemsByUserID.defaultExpectation == nil && mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItemsByUserID.mock.afterDeleteItemsByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItemsByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItemsByUserID implements mm_cart.repository
func (mmDeleteItemsByUserID *RepositoryMock) DeleteItemsByUserID(ctx context.Context, userID uint64) (err error) {
	mm_atomic.AddUint64(&mmDeleteItemsByUserID.beforeDeleteItemsByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItemsByUserID.afterDeleteItemsByUserIDCounter, 1)

	mmDeleteItemsByUserID.t.Helper()

	if mmDeleteItemsByUserID.inspectFuncDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.inspectFuncDeleteItemsByUserID(ctx, userID)
	}

	mm_params := RepositoryMockDeleteItemsByUserIDParams{ctx, userID}

	// Record call args
	mmDeleteItemsByUserID.DeleteItemsByUserIDMock.mutex.Lock()
	mmDeleteItemsByUserID.DeleteItemsByUserIDMock.callArgs = append(mmDeleteItemsByUserID.DeleteItemsByUserIDMock.callArgs, &mm_params)
	mmDeleteItemsByUserID.DeleteItemsByUserIDMock.mutex.Unlock()

	for _, e := range mmDeleteItemsByUserID.DeleteItemsByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteItemsByUserIDParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteItemsByUserID.t.Errorf("RepositoryMock.DeleteItemsByUserID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteItemsByUserID.t.Errorf("RepositoryMock.DeleteItemsByUserID got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItemsByUserID.t.Errorf("RepositoryMock.DeleteItemsByUserID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItemsByUserID.t.Fatal("No results are set for the RepositoryMock.DeleteItemsByUserID")
		}
		return (*mm_results).err
	}
	if mmDeleteItemsByUserID.funcDeleteItemsByUserID != nil {
		return mmDeleteItemsByUserID.funcDeleteItemsByUserID(ctx, userID)
	}
	mmDeleteItemsByUserID.t.Fatalf("Unexpected call to RepositoryMock.DeleteItemsByUserID. %v %v", ctx, userID)
	return
}

// DeleteItemsByUserIDAfterCounter returns a count of finished RepositoryMock.DeleteItemsByUserID invocations
func (mmDeleteItemsByUserID *RepositoryMock) DeleteItemsByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemsByUserID.afterDeleteItemsByUserIDCounter)
}

// DeleteItemsByUserIDBeforeCounter returns a count of RepositoryMock.DeleteItemsByUserID invocations
func (mmDeleteItemsByUserID *RepositoryMock) DeleteItemsByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemsByUserID.beforeDeleteItemsByUserIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteItemsByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItemsByUserID *mRepositoryMockDeleteItemsByUserID) Calls() []*RepositoryMockDeleteItemsByUserIDParams {
	mmDeleteItemsByUserID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteItemsByUserIDParams, len(mmDeleteItemsByUserID.callArgs))
	copy(argCopy, mmDeleteItemsByUserID.callArgs)

	mmDeleteItemsByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemsByUserIDDone returns true if the count of the DeleteItemsByUserID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteItemsByUserIDDone() bool {
	if m.DeleteItemsByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemsByUserIDMock.invocationsDone()
}

// MinimockDeleteItemsByUserIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteItemsByUserIDInspect() {
	for _, e := range m.DeleteItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteItemsByUserID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteItemsByUserIDCounter := mm_atomic.LoadUint64(&m.afterDeleteItemsByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemsByUserIDMock.defaultExpectation != nil && afterDeleteItemsByUserIDCounter < 1 {
		if m.DeleteItemsByUserIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteItemsByUserID at\n%s", m.DeleteItemsByUserIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteItemsByUserID at\n%s with params: %#v", m.DeleteItemsByUserIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteItemsByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItemsByUserID != nil && afterDeleteItemsByUserIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteItemsByUserID at\n%s", m.funcDeleteItemsByUserIDOrigin)
	}

	if !m.DeleteItemsByUserIDMock.invocationsDone() && afterDeleteItemsByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteItemsByUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemsByUserIDMock.expectedInvocations), m.DeleteItemsByUserIDMock.expectedInvocationsOrigin, afterDeleteItemsByUserIDCounter)
	}
}

type mRepositoryMockGetItemOfUserIDBySku struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetItemOfUserIDBySkuExpectation
	expectations       []*RepositoryMockGetItemOfUserIDBySkuExpectation

	callArgs []*RepositoryMockGetItemOfUserIDBySkuParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetItemOfUserIDBySkuExpectation specifies expectation struct of the repository.GetItemOfUserIDBySku
type RepositoryMockGetItemOfUserIDBySkuExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetItemOfUserIDBySkuParams
	paramPtrs          *RepositoryMockGetItemOfUserIDBySkuParamPtrs
	expectationOrigins RepositoryMockGetItemOfUserIDBySkuExpectationOrigins
	results            *RepositoryMockGetItemOfUserIDBySkuResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetItemOfUserIDBySkuParams contains parameters of the repository.GetItemOfUserIDBySku
type RepositoryMockGetItemOfUserIDBySkuParams struct {
	ctx    context.Context
	userID uint64
	sku    domain.Sku
}

// RepositoryMockGetItemOfUserIDBySkuParamPtrs contains pointers to parameters of the repository.GetItemOfUserIDBySku
type RepositoryMockGetItemOfUserIDBySkuParamPtrs struct {
	ctx    *context.Context
	userID *uint64
	sku    *domain.Sku
}

// RepositoryMockGetItemOfUserIDBySkuResults contains results of the repository.GetItemOfUserIDBySku
type RepositoryMockGetItemOfUserIDBySkuResults struct {
	i1  domain.Item
	err error
}

// RepositoryMockGetItemOfUserIDBySkuOrigins contains origins of expectations of the repository.GetItemOfUserIDBySku
type RepositoryMockGetItemOfUserIDBySkuExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originSku    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetItemOfUserIDBySku *mRepositoryMockGetItemOfUserIDBySku) Optional() *mRepositoryMockGetItemOfUserIDBySku {
	mmGetItemOfUserIDBySku.optional = true
	return mmGetItemOfUserIDBySku
}

// Expect sets up expected params for repository.GetItemOfUserIDBySku
func (mmGetItemOfUserIDBySku *mRepositoryMockGetItemOfUserIDBySku) Expect(ctx context.Context, userID uint64, sku domain.Sku) *mRepositoryMockGetItemOfUserIDBySku {
	if mmGetItemOfUserIDBySku.mock.funcGetItemOfUserIDBySku != nil {
		mmGetItemOfUserIDBySku.mock.t.Fatalf("RepositoryMock.GetItemOfUserIDBySku mock is already set by Set")
	}

	if mmGetItemOfUserIDBySku.defaultExpectation == nil {
		mmGetItemOfUserIDBySku.defaultExpectation = &RepositoryMockGetItemOfUserIDBySkuExpectation{}
	}

	if mmGetItemOfUserIDBySku.defaultExpectation.paramPtrs != nil {
		mmGetItemOfUserIDBySku.mock.t.Fatalf("RepositoryMock.GetItemOfUserIDBySku mock is already set by ExpectParams functions")
	}

	mmGetItemOfUserIDBySku.defaultExpectation.params = &RepositoryMockGetItemOfUserIDBySkuParams{ctx, userID, sku}
	mmGetItemOfUserIDBySku.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetItemOfUserIDBySku.expectations {
		if minimock.Equal(e.params, mmGetItemOfUserIDBySku.defaultExpectation.params) {
			mmGetItemOfUserIDBySku.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItemOfUserIDBySku.defaultExpectation.params)
		}
	}

	return mmGetItemOfUserIDBySku
}

// ExpectCtxParam1 sets up expected param ctx for repository.GetItemOfUserIDBySku
func (mmGetItemOfUserIDBySku *mRepositoryMockGetItemOfUserIDBySku) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetItemOfUserIDBySku {
	if mmGetItemOfUserIDBySku.mock.funcGetItemOfUserIDBySku != nil {
		mmGetItemOfUserIDBySku.mock.t.Fatalf("RepositoryMock.GetItemOfUserIDBySku mock is already set by Set")
	}

	if mmGetItemOfUserIDBySku.defaultExpectation == nil {
		mmGetItemOfUserIDBySku.defaultExpectation = &RepositoryMockGetItemOfUserIDBySkuExpectation{}
	}

	if mmGetItemOfUserIDBySku.defaultExpectation.params != nil {
		mmGetItemOfUserIDBySku.mock.t.Fatalf("RepositoryMock.GetItemOfUserIDBySku mock is already set by Expect")
	}

	if mmGetItemOfUserIDBySku.defaultExpectation.paramPtrs == nil {
		mmGetItemOfUserIDBySku.defaultExpectation.paramPtrs = &RepositoryMockGetItemOfUserIDBySkuParamPtrs{}
	}
	mmGetItemOfUserIDBySku.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetItemOfUserIDBySku.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetItemOfUserIDBySku
}

// ExpectUserIDParam2 sets up expected param userID for repository.GetItemOfUserIDBySku
func (mmGetItemOfUserIDBySku *mRepositoryMockGetItemOfUserIDBySku) ExpectUserIDParam2(userID uint64) *mRepositoryMockGetItemOfUserIDBySku {
	if mmGetItemOfUserIDBySku.mock.funcGetItemOfUserIDBySku != nil {
		mmGetItemOfUserIDBySku.mock.t.Fatalf("RepositoryMock.GetItemOfUserIDBySku mock is already set by Set")
	}

	if mmGetItemOfUserIDBySku.defaultExpectation == nil {
		mmGetItemOfUserIDBySku.defaultExpectation = &RepositoryMockGetItemOfUserIDBySkuExpectation{}
	}

	if mmGetItemOfUserIDBySku.defaultExpectation.params != nil {
		mmGetItemOfUserIDBySku.mock.t.Fatalf("RepositoryMock.GetItemOfUserIDBySku mock is already set by Expect")
	}

	if mmGetItemOfUserIDBySku.defaultExpectation.paramPtrs == nil {
		mmGetItemOfUserIDBySku.defaultExpectation.paramPtrs = &RepositoryMockGetItemOfUserIDBySkuParamPtrs{}
	}
	mmGetItemOfUserIDBySku.defaultExpectation.paramPtrs.userID = &userID
	mmGetItemOfUserIDBySku.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetItemOfUserIDBySku
}

// ExpectSkuParam3 sets up expected param sku for repository.GetItemOfUserIDBySku
func (mmGetItemOfUserIDBySku *mRepositoryMockGetItemOfUserIDBySku) ExpectSkuParam3(sku domain.Sku) *mRepositoryMockGetItemOfUserIDBySku {
	if mmGetItemOfUserIDBySku.mock.funcGetItemOfUserIDBySku != nil {
		mmGetItemOfUserIDBySku.mock.t.Fatalf("RepositoryMock.GetItemOfUserIDBySku mock is already set by Set")
	}

	if mmGetItemOfUserIDBySku.defaultExpectation == nil {
		mmGetItemOfUserIDBySku.defaultExpectation = &RepositoryMockGetItemOfUserIDBySkuExpectation{}
	}

	if mmGetItemOfUserIDBySku.defaultExpectation.params != nil {
		mmGetItemOfUserIDBySku.mock.t.Fatalf("RepositoryMock.GetItemOfUserIDBySku mock is already set by Expect")
	}

	if mmGetItemOfUserIDBySku.defaultExpectation.paramPtrs == nil {
		mmGetItemOfUserIDBySku.defaultExpectation.paramPtrs = &RepositoryMockGetItemOfUserIDBySkuParamPtrs{}
	}
	mmGetItemOfUserIDBySku.defaultExpectation.paramPtrs.sku = &sku
	mmGetItemOfUserIDBySku.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmGetItemOfUserIDBySku
}

// Inspect accepts an inspector function that has same arguments as the repository.GetItemOfUserIDBySku
func (mmGetItemOfUserIDBySku *mRepositoryMockGetItemOfUserIDBySku) Inspect(f func(ctx context.Context, userID uint64, sku domain.Sku)) *mRepositoryMockGetItemOfUserIDBySku {
	if mmGetItemOfUserIDBySku.mock.inspectFuncGetItemOfUserIDBySku != nil {
		mmGetItemOfUserIDBySku.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetItemOfUserIDBySku")
	}

	mmGetItemOfUserIDBySku.mock.inspectFuncGetItemOfUserIDBySku = f

	return mmGetItemOfUserIDBySku
}

// Return sets up results that will be returned by repository.GetItemOfUserIDBySku
func (mmGetItemOfUserIDBySku *mRepositoryMockGetItemOfUserIDBySku) Return(i1 domain.Item, err error) *RepositoryMock {
	if mmGetItemOfUserIDBySku.mock.funcGetItemOfUserIDBySku != nil {
		mmGetItemOfUserIDBySku.mock.t.Fatalf("RepositoryMock.GetItemOfUserIDBySku mock is already set by Set")
	}

	if mmGetItemOfUserIDBySku.defaultExpectation == nil {
		mmGetItemOfUserIDBySku.defaultExpectation = &RepositoryMockGetItemOfUserIDBySkuExpectation{mock: mmGetItemOfUserIDBySku.mock}
	}
	mmGetItemOfUserIDBySku.defaultExpectation.results = &RepositoryMockGetItemOfUserIDBySkuResults{i1, err}
	mmGetItemOfUserIDBySku.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetItemOfUserIDBySku.mock
}

// Set uses given function f to mock the repository.GetItemOfUserIDBySku method
func (mmGetItemOfUserIDBySku *mRepositoryMockGetItemOfUserIDBySku) Set(f func(ctx context.Context, userID uint64, sku domain.Sku) (i1 domain.Item, err error)) *RepositoryMock {
	if mmGetItemOfUserIDBySku.defaultExpectation != nil {
		mmGetItemOfUserIDBySku.mock.t.Fatalf("Default expectation is already set for the repository.GetItemOfUserIDBySku method")
	}

	if len(mmGetItemOfUserIDBySku.expectations) > 0 {
		mmGetItemOfUserIDBySku.mock.t.Fatalf("Some expectations are already set for the repository.GetItemOfUserIDBySku method")
	}

	mmGetItemOfUserIDBySku.mock.funcGetItemOfUserIDBySku = f
	mmGetItemOfUserIDBySku.mock.funcGetItemOfUserIDBySkuOrigin = minimock.CallerInfo(1)
	return mmGetItemOfUserIDBySku.mock
}

// When sets expectation for the repository.GetItemOfUserIDBySku which will trigger the result defined by the following
// Then helper
func (mmGetItemOfUserIDBySku *mRepositoryMockGetItemOfUserIDBySku) When(ctx context.Context, userID uint64, sku domain.Sku) *RepositoryMockGetItemOfUserIDBySkuExpectation {
	if mmGetItemOfUserIDBySku.mock.funcGetItemOfUserIDBySku != nil {
		mmGetItemOfUserIDBySku.mock.t.Fatalf("RepositoryMock.GetItemOfUserIDBySku mock is already set by Set")
	}

	expectation := &RepositoryMockGetItemOfUserIDBySkuExpectation{
		mock:               mmGetItemOfUserIDBySku.mock,
		params:             &RepositoryMockGetItemOfUserIDBySkuParams{ctx, userID, sku},
		expectationOrigins: RepositoryMockGetItemOfUserIDBySkuExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetItemOfUserIDBySku.expectations = append(mmGetItemOfUserIDBySku.expectations, expectation)
	return expectation
}

// Then sets up repository.GetItemOfUserIDBySku return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetItemOfUserIDBySkuExpectation) Then(i1 domain.Item, err error) *RepositoryMock {
	e.results = &RepositoryMockGetItemOfUserIDBySkuResults{i1, err}
	return e.mock
}

// Times sets number of times repository.GetItemOfUserIDBySku should be invoked
func (mmGetItemOfUserIDBySku *mRepositoryMockGetItemOfUserIDBySku) Times(n uint64) *mRepositoryMockGetItemOfUserIDBySku {
	if n == 0 {
		mmGetItemOfUserIDBySku.mock.t.Fatalf("Times of RepositoryMock.GetItemOfUserIDBySku mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetItemOfUserIDBySku.expectedInvocations, n)
	mmGetItemOfUserIDBySku.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetItemOfUserIDBySku
}

func (mmGetItemOfUserIDBySku *mRepositoryMockGetItemOfUserIDBySku) invocationsDone() bool {
	if len(mmGetItemOfUserIDBySku.expectations) == 0 && mmGetItemOfUserIDBySku.defaultExpectation == nil && mmGetItemOfUserIDBySku.mock.funcGetItemOfUserIDBySku == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetItemOfUserIDBySku.mock.afterGetItemOfUserIDBySkuCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetItemOfUserIDBySku.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetItemOfUserIDBySku implements mm_cart.repository
func (mmGetItemOfUserIDBySku *RepositoryMock) GetItemOfUserIDBySku(ctx context.Context, userID uint64, sku domain.Sku) (i1 domain.Item, err error) {
	mm_atomic.AddUint64(&mmGetItemOfUserIDBySku.beforeGetItemOfUserIDBySkuCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItemOfUserIDBySku.afterGetItemOfUserIDBySkuCounter, 1)

	mmGetItemOfUserIDBySku.t.Helper()

	if mmGetItemOfUserIDBySku.inspectFuncGetItemOfUserIDBySku != nil {
		mmGetItemOfUserIDBySku.inspectFuncGetItemOfUserIDBySku(ctx, userID, sku)
	}

	mm_params := RepositoryMockGetItemOfUserIDBySkuParams{ctx, userID, sku}

	// Record call args
	mmGetItemOfUserIDBySku.GetItemOfUserIDBySkuMock.mutex.Lock()
	mmGetItemOfUserIDBySku.GetItemOfUserIDBySkuMock.callArgs = append(mmGetItemOfUserIDBySku.GetItemOfUserIDBySkuMock.callArgs, &mm_params)
	mmGetItemOfUserIDBySku.GetItemOfUserIDBySkuMock.mutex.Unlock()

	for _, e := range mmGetItemOfUserIDBySku.GetItemOfUserIDBySkuMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetItemOfUserIDBySku.GetItemOfUserIDBySkuMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItemOfUserIDBySku.GetItemOfUserIDBySkuMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItemOfUserIDBySku.GetItemOfUserIDBySkuMock.defaultExpectation.params
		mm_want_ptrs := mmGetItemOfUserIDBySku.GetItemOfUserIDBySkuMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetItemOfUserIDBySkuParams{ctx, userID, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetItemOfUserIDBySku.t.Errorf("RepositoryMock.GetItemOfUserIDBySku got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItemOfUserIDBySku.GetItemOfUserIDBySkuMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetItemOfUserIDBySku.t.Errorf("RepositoryMock.GetItemOfUserIDBySku got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItemOfUserIDBySku.GetItemOfUserIDBySkuMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmGetItemOfUserIDBySku.t.Errorf("RepositoryMock.GetItemOfUserIDBySku got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItemOfUserIDBySku.GetItemOfUserIDBySkuMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItemOfUserIDBySku.t.Errorf("RepositoryMock.GetItemOfUserIDBySku got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetItemOfUserIDBySku.GetItemOfUserIDBySkuMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItemOfUserIDBySku.GetItemOfUserIDBySkuMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItemOfUserIDBySku.t.Fatal("No results are set for the RepositoryMock.GetItemOfUserIDBySku")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetItemOfUserIDBySku.funcGetItemOfUserIDBySku != nil {
		return mmGetItemOfUserIDBySku.funcGetItemOfUserIDBySku(ctx, userID, sku)
	}
	mmGetItemOfUserIDBySku.t.Fatalf("Unexpected call to RepositoryMock.GetItemOfUserIDBySku. %v %v %v", ctx, userID, sku)
	return
}

// GetItemOfUserIDBySkuAfterCounter returns a count of finished RepositoryMock.GetItemOfUserIDBySku invocations
func (mmGetItemOfUserIDBySku *RepositoryMock) GetItemOfUserIDBySkuAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemOfUserIDBySku.afterGetItemOfUserIDBySkuCounter)
}

// GetItemOfUserIDBySkuBeforeCounter returns a count of RepositoryMock.GetItemOfUserIDBySku invocations
func (mmGetItemOfUserIDBySku *RepositoryMock) GetItemOfUserIDBySkuBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemOfUserIDBySku.beforeGetItemOfUserIDBySkuCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetItemOfUserIDBySku.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItemOfUserIDBySku *mRepositoryMockGetItemOfUserIDBySku) Calls() []*RepositoryMockGetItemOfUserIDBySkuParams {
	mmGetItemOfUserIDBySku.mutex.RLock()

	argCopy := make([]*RepositoryMockGetItemOfUserIDBySkuParams, len(mmGetItemOfUserIDBySku.callArgs))
	copy(argCopy, mmGetItemOfUserIDBySku.callArgs)

	mmGetItemOfUserIDBySku.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemOfUserIDBySkuDone returns true if the count of the GetItemOfUserIDBySku invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetItemOfUserIDBySkuDone() bool {
	if m.GetItemOfUserIDBySkuMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetItemOfUserIDBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetItemOfUserIDBySkuMock.invocationsDone()
}

// MinimockGetItemOfUserIDBySkuInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetItemOfUserIDBySkuInspect() {
	for _, e := range m.GetItemOfUserIDBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetItemOfUserIDBySku at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetItemOfUserIDBySkuCounter := mm_atomic.LoadUint64(&m.afterGetItemOfUserIDBySkuCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemOfUserIDBySkuMock.defaultExpectation != nil && afterGetItemOfUserIDBySkuCounter < 1 {
		if m.GetItemOfUserIDBySkuMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetItemOfUserIDBySku at\n%s", m.GetItemOfUserIDBySkuMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetItemOfUserIDBySku at\n%s with params: %#v", m.GetItemOfUserIDBySkuMock.defaultExpectation.expectationOrigins.origin, *m.GetItemOfUserIDBySkuMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemOfUserIDBySku != nil && afterGetItemOfUserIDBySkuCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetItemOfUserIDBySku at\n%s", m.funcGetItemOfUserIDBySkuOrigin)
	}

	if !m.GetItemOfUserIDBySkuMock.invocationsDone() && afterGetItemOfUserIDBySkuCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetItemOfUserIDBySku at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetItemOfUserIDBySkuMock.expectedInvocations), m.GetItemOfUserIDBySkuMock.expectedInvocationsOrigin, afterGetItemOfUserIDBySkuCounter)
	}
}

type mRepositoryMockGetItemsByUserID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetItemsByUserIDExpectation
	expectations       []*RepositoryMockGetItemsByUserIDExpectation

	callArgs []*RepositoryMockGetItemsByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetItemsByUserIDExpectation specifies expectation struct of the repository.GetItemsByUserID
type RepositoryMockGetItemsByUserIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetItemsByUserIDParams
	paramPtrs          *RepositoryMockGetItemsByUserIDParamPtrs
	expectationOrigins RepositoryMockGetItemsByUserIDExpectationOrigins
	results            *RepositoryMockGetItemsByUserIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetItemsByUserIDParams contains parameters of the repository.GetItemsByUserID
type RepositoryMockGetItemsByUserIDParams struct {
	ctx    context.Context
	userID uint64
}

// RepositoryMockGetItemsByUserIDParamPtrs contains pointers to parameters of the repository.GetItemsByUserID
type RepositoryMockGetItemsByUserIDParamPtrs struct {
	ctx    *context.Context
	userID *uint64
}

// RepositoryMockGetItemsByUserIDResults contains results of the repository.GetItemsByUserID
type RepositoryMockGetItemsByUserIDResults struct {
	ia1 []domain.Item
	err error
}

// RepositoryMockGetItemsByUserIDOrigins contains origins of expectations of the repository.GetItemsByUserID
type RepositoryMockGetItemsByUserIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) Optional() *mRepositoryMockGetItemsByUserID {
	mmGetItemsByUserID.optional = true
	return mmGetItemsByUserID
}

// Expect sets up expected params for repository.GetItemsByUserID
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) Expect(ctx context.Context, userID uint64) *mRepositoryMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &RepositoryMockGetItemsByUserIDExpectation{}
	}

	if mmGetItemsByUserID.defaultExpectation.paramPtrs != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by ExpectParams functions")
	}

	mmGetItemsByUserID.defaultExpectation.params = &RepositoryMockGetItemsByUserIDParams{ctx, userID}
	mmGetItemsByUserID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetItemsByUserID.expectations {
		if minimock.Equal(e.params, mmGetItemsByUserID.defaultExpectation.params) {
			mmGetItemsByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItemsByUserID.defaultExpectation.params)
		}
	}

	return mmGetItemsByUserID
}

// ExpectCtxParam1 sets up expected param ctx for repository.GetItemsByUserID
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &RepositoryMockGetItemsByUserIDExpectation{}
	}

	if mmGetItemsByUserID.defaultExpectation.params != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by Expect")
	}

	if mmGetItemsByUserID.defaultExpectation.paramPtrs == nil {
		mmGetItemsByUserID.defaultExpectation.paramPtrs = &RepositoryMockGetItemsByUserIDParamPtrs{}
	}
	mmGetItemsByUserID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetItemsByUserID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetItemsByUserID
}

// ExpectUserIDParam2 sets up expected param userID for repository.GetItemsByUserID
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) ExpectUserIDParam2(userID uint64) *mRepositoryMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &RepositoryMockGetItemsByUserIDExpectation{}
	}

	if mmGetItemsByUserID.defaultExpectation.params != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by Expect")
	}

	if mmGetItemsByUserID.defaultExpectation.paramPtrs == nil {
		mmGetItemsByUserID.defaultExpectation.paramPtrs = &RepositoryMockGetItemsByUserIDParamPtrs{}
	}
	mmGetItemsByUserID.defaultExpectation.paramPtrs.userID = &userID
	mmGetItemsByUserID.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetItemsByUserID
}

// Inspect accepts an inspector function that has same arguments as the repository.GetItemsByUserID
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) Inspect(f func(ctx context.Context, userID uint64)) *mRepositoryMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.inspectFuncGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetItemsByUserID")
	}

	mmGetItemsByUserID.mock.inspectFuncGetItemsByUserID = f

	return mmGetItemsByUserID
}

// Return sets up results that will be returned by repository.GetItemsByUserID
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) Return(ia1 []domain.Item, err error) *RepositoryMock {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &RepositoryMockGetItemsByUserIDExpectation{mock: mmGetItemsByUserID.mock}
	}
	mmGetItemsByUserID.defaultExpectation.results = &RepositoryMockGetItemsByUserIDResults{ia1, err}
	mmGetItemsByUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetItemsByUserID.mock
}

// Set uses given function f to mock the repository.GetItemsByUserID method
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) Set(f func(ctx context.Context, userID uint64) (ia1 []domain.Item, err error)) *RepositoryMock {
	if mmGetItemsByUserID.defaultExpectation != nil {
		mmGetItemsByUserID.mock.t.Fatalf("Default expectation is already set for the repository.GetItemsByUserID method")
	}

	if len(mmGetItemsByUserID.expectations) > 0 {
		mmGetItemsByUserID.mock.t.Fatalf("Some expectations are already set for the repository.GetItemsByUserID method")
	}

	mmGetItemsByUserID.mock.funcGetItemsByUserID = f
	mmGetItemsByUserID.mock.funcGetItemsByUserIDOrigin = minimock.CallerInfo(1)
	return mmGetItemsByUserID.mock
}

// When sets expectation for the repository.GetItemsByUserID which will trigger the result defined by the following
// Then helper
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) When(ctx context.Context, userID uint64) *RepositoryMockGetItemsByUserIDExpectation {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by Set")
	}

	expectation := &RepositoryMockGetItemsByUserIDExpectation{
		mock:               mmGetItemsByUserID.mock,
		params:             &RepositoryMockGetItemsByUserIDParams{ctx, userID},
		expectationOrigins: RepositoryMockGetItemsByUserIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetItemsByUserID.expectations = append(mmGetItemsByUserID.expectations, expectation)
	return expectation
}

// Then sets up repository.GetItemsByUserID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetItemsByUserIDExpectation) Then(ia1 []domain.Item, err error) *RepositoryMock {
	e.results = &RepositoryMockGetItemsByUserIDResults{ia1, err}
	return e.mock
}

// Times sets number of times repository.GetItemsByUserID should be invoked
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) Times(n uint64) *mRepositoryMockGetItemsByUserID {
	if n == 0 {
		mmGetItemsByUserID.mock.t.Fatalf("Times of RepositoryMock.GetItemsByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetItemsByUserID.expectedInvocations, n)
	mmGetItemsByUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetItemsByUserID
}

func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) invocationsDone() bool {
	if len(mmGetItemsByUserID.expectations) == 0 && mmGetItemsByUserID.defaultExpectation == nil && mmGetItemsByUserID.mock.funcGetItemsByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetItemsByUserID.mock.afterGetItemsByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetItemsByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetItemsByUserID implements mm_cart.repository
func (mmGetItemsByUserID *RepositoryMock) GetItemsByUserID(ctx context.Context, userID uint64) (ia1 []domain.Item, err error) {
	mm_atomic.AddUint64(&mmGetItemsByUserID.beforeGetItemsByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItemsByUserID.afterGetItemsByUserIDCounter, 1)

	mmGetItemsByUserID.t.Helper()

	if mmGetItemsByUserID.inspectFuncGetItemsByUserID != nil {
		mmGetItemsByUserID.inspectFuncGetItemsByUserID(ctx, userID)
	}

	mm_params := RepositoryMockGetItemsByUserIDParams{ctx, userID}

	// Record call args
	mmGetItemsByUserID.GetItemsByUserIDMock.mutex.Lock()
	mmGetItemsByUserID.GetItemsByUserIDMock.callArgs = append(mmGetItemsByUserID.GetItemsByUserIDMock.callArgs, &mm_params)
	mmGetItemsByUserID.GetItemsByUserIDMock.mutex.Unlock()

	for _, e := range mmGetItemsByUserID.GetItemsByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetItemsByUserIDParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetItemsByUserID.t.Errorf("RepositoryMock.GetItemsByUserID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetItemsByUserID.t.Errorf("RepositoryMock.GetItemsByUserID got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItemsByUserID.t.Errorf("RepositoryMock.GetItemsByUserID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItemsByUserID.t.Fatal("No results are set for the RepositoryMock.GetItemsByUserID")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmGetItemsByUserID.funcGetItemsByUserID != nil {
		return mmGetItemsByUserID.funcGetItemsByUserID(ctx, userID)
	}
	mmGetItemsByUserID.t.Fatalf("Unexpected call to RepositoryMock.GetItemsByUserID. %v %v", ctx, userID)
	return
}

// GetItemsByUserIDAfterCounter returns a count of finished RepositoryMock.GetItemsByUserID invocations
func (mmGetItemsByUserID *RepositoryMock) GetItemsByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByUserID.afterGetItemsByUserIDCounter)
}

// GetItemsByUserIDBeforeCounter returns a count of RepositoryMock.GetItemsByUserID invocations
func (mmGetItemsByUserID *RepositoryMock) GetItemsByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByUserID.beforeGetItemsByUserIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetItemsByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) Calls() []*RepositoryMockGetItemsByUserIDParams {
	mmGetItemsByUserID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetItemsByUserIDParams, len(mmGetItemsByUserID.callArgs))
	copy(argCopy, mmGetItemsByUserID.callArgs)

	mmGetItemsByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemsByUserIDDone returns true if the count of the GetItemsByUserID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetItemsByUserIDDone() bool {
	if m.GetItemsByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetItemsByUserIDMock.invocationsDone()
}

// MinimockGetItemsByUserIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetItemsByUserIDInspect() {
	for _, e := range m.GetItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetItemsByUserID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetItemsByUserIDCounter := mm_atomic.LoadUint64(&m.afterGetItemsByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemsByUserIDMock.defaultExpectation != nil && afterGetItemsByUserIDCounter < 1 {
		if m.GetItemsByUserIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetItemsByUserID at\n%s", m.GetItemsByUserIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetItemsByUserID at\n%s with params: %#v", m.GetItemsByUserIDMock.defaultExpectation.expectationOrigins.origin, *m.GetItemsByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemsByUserID != nil && afterGetItemsByUserIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetItemsByUserID at\n%s", m.funcGetItemsByUserIDOrigin)
	}

	if !m.GetItemsByUserIDMock.invocationsDone() && afterGetItemsByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetItemsByUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetItemsByUserIDMock.expectedInvocations), m.GetItemsByUserIDMock.expectedInvocationsOrigin, afterGetItemsByUserIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemInspect()

			m.MinimockDeleteItemInspect()

			m.MinimockDeleteItemsByUserIDInspect()

			m.MinimockGetItemOfUserIDBySkuInspect()

			m.MinimockGetItemsByUserIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockDeleteItemDone() &&
		m.MinimockDeleteItemsByUserIDDone() &&
		m.MinimockGetItemOfUserIDBySkuDone() &&
		m.MinimockGetItemsByUserIDDone()
}
